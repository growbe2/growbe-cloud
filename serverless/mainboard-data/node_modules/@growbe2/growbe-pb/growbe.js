/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * AlarmZone enum.
     * @exports AlarmZone
     * @enum {string}
     * @property {number} UNKNOW=0 UNKNOW value
     * @property {number} MIDDLE=1 MIDDLE value
     * @property {number} VERY_LOW=2 VERY_LOW value
     * @property {number} LOW=3 LOW value
     * @property {number} HIGH=4 HIGH value
     * @property {number} VERY_HIGH=5 VERY_HIGH value
     */
    $root.AlarmZone = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOW"] = 0;
        values[valuesById[1] = "MIDDLE"] = 1;
        values[valuesById[2] = "VERY_LOW"] = 2;
        values[valuesById[3] = "LOW"] = 3;
        values[valuesById[4] = "HIGH"] = 4;
        values[valuesById[5] = "VERY_HIGH"] = 5;
        return values;
    })();
    
    $root.AlarmZoneValue = (function() {
    
        /**
         * Properties of an AlarmZoneValue.
         * @exports IAlarmZoneValue
         * @interface IAlarmZoneValue
         * @property {number|null} [value] AlarmZoneValue value
         * @property {number|null} [offset] AlarmZoneValue offset
         */
    
        /**
         * Constructs a new AlarmZoneValue.
         * @exports AlarmZoneValue
         * @classdesc Represents an AlarmZoneValue.
         * @implements IAlarmZoneValue
         * @constructor
         * @param {IAlarmZoneValue=} [properties] Properties to set
         */
        function AlarmZoneValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * AlarmZoneValue value.
         * @member {number} value
         * @memberof AlarmZoneValue
         * @instance
         */
        AlarmZoneValue.prototype.value = 0;
    
        /**
         * AlarmZoneValue offset.
         * @member {number} offset
         * @memberof AlarmZoneValue
         * @instance
         */
        AlarmZoneValue.prototype.offset = 0;
    
        /**
         * Creates a new AlarmZoneValue instance using the specified properties.
         * @function create
         * @memberof AlarmZoneValue
         * @static
         * @param {IAlarmZoneValue=} [properties] Properties to set
         * @returns {AlarmZoneValue} AlarmZoneValue instance
         */
        AlarmZoneValue.create = function create(properties) {
            return new AlarmZoneValue(properties);
        };
    
        /**
         * Encodes the specified AlarmZoneValue message. Does not implicitly {@link AlarmZoneValue.verify|verify} messages.
         * @function encode
         * @memberof AlarmZoneValue
         * @static
         * @param {IAlarmZoneValue} message AlarmZoneValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlarmZoneValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.offset);
            return writer;
        };
    
        /**
         * Encodes the specified AlarmZoneValue message, length delimited. Does not implicitly {@link AlarmZoneValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AlarmZoneValue
         * @static
         * @param {IAlarmZoneValue} message AlarmZoneValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlarmZoneValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AlarmZoneValue message from the specified reader or buffer.
         * @function decode
         * @memberof AlarmZoneValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AlarmZoneValue} AlarmZoneValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlarmZoneValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlarmZoneValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.uint32();
                    break;
                case 2:
                    message.offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an AlarmZoneValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AlarmZoneValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AlarmZoneValue} AlarmZoneValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlarmZoneValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AlarmZoneValue message.
         * @function verify
         * @memberof AlarmZoneValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlarmZoneValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };
    
        /**
         * Creates an AlarmZoneValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AlarmZoneValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AlarmZoneValue} AlarmZoneValue
         */
        AlarmZoneValue.fromObject = function fromObject(object) {
            if (object instanceof $root.AlarmZoneValue)
                return object;
            var message = new $root.AlarmZoneValue();
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from an AlarmZoneValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AlarmZoneValue
         * @static
         * @param {AlarmZoneValue} message AlarmZoneValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlarmZoneValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.value = 0;
                object.offset = 0;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };
    
        /**
         * Converts this AlarmZoneValue to JSON.
         * @function toJSON
         * @memberof AlarmZoneValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlarmZoneValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AlarmZoneValue;
    })();
    
    $root.FieldAlarm = (function() {
    
        /**
         * Properties of a FieldAlarm.
         * @exports IFieldAlarm
         * @interface IFieldAlarm
         * @property {string|null} [moduleId] FieldAlarm moduleId
         * @property {string|null} [property] FieldAlarm property
         * @property {IAlarmZoneValue|null} [veryLow] FieldAlarm veryLow
         * @property {IAlarmZoneValue|null} [low] FieldAlarm low
         * @property {IAlarmZoneValue|null} [high] FieldAlarm high
         * @property {IAlarmZoneValue|null} [veryHigh] FieldAlarm veryHigh
         */
    
        /**
         * Constructs a new FieldAlarm.
         * @exports FieldAlarm
         * @classdesc Represents a FieldAlarm.
         * @implements IFieldAlarm
         * @constructor
         * @param {IFieldAlarm=} [properties] Properties to set
         */
        function FieldAlarm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * FieldAlarm moduleId.
         * @member {string} moduleId
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.moduleId = "";
    
        /**
         * FieldAlarm property.
         * @member {string} property
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.property = "";
    
        /**
         * FieldAlarm veryLow.
         * @member {IAlarmZoneValue|null|undefined} veryLow
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.veryLow = null;
    
        /**
         * FieldAlarm low.
         * @member {IAlarmZoneValue|null|undefined} low
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.low = null;
    
        /**
         * FieldAlarm high.
         * @member {IAlarmZoneValue|null|undefined} high
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.high = null;
    
        /**
         * FieldAlarm veryHigh.
         * @member {IAlarmZoneValue|null|undefined} veryHigh
         * @memberof FieldAlarm
         * @instance
         */
        FieldAlarm.prototype.veryHigh = null;
    
        /**
         * Creates a new FieldAlarm instance using the specified properties.
         * @function create
         * @memberof FieldAlarm
         * @static
         * @param {IFieldAlarm=} [properties] Properties to set
         * @returns {FieldAlarm} FieldAlarm instance
         */
        FieldAlarm.create = function create(properties) {
            return new FieldAlarm(properties);
        };
    
        /**
         * Encodes the specified FieldAlarm message. Does not implicitly {@link FieldAlarm.verify|verify} messages.
         * @function encode
         * @memberof FieldAlarm
         * @static
         * @param {IFieldAlarm} message FieldAlarm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldAlarm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moduleId != null && Object.hasOwnProperty.call(message, "moduleId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.moduleId);
            if (message.property != null && Object.hasOwnProperty.call(message, "property"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.property);
            if (message.veryLow != null && Object.hasOwnProperty.call(message, "veryLow"))
                $root.AlarmZoneValue.encode(message.veryLow, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.low != null && Object.hasOwnProperty.call(message, "low"))
                $root.AlarmZoneValue.encode(message.low, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.high != null && Object.hasOwnProperty.call(message, "high"))
                $root.AlarmZoneValue.encode(message.high, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.veryHigh != null && Object.hasOwnProperty.call(message, "veryHigh"))
                $root.AlarmZoneValue.encode(message.veryHigh, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified FieldAlarm message, length delimited. Does not implicitly {@link FieldAlarm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof FieldAlarm
         * @static
         * @param {IFieldAlarm} message FieldAlarm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldAlarm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a FieldAlarm message from the specified reader or buffer.
         * @function decode
         * @memberof FieldAlarm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FieldAlarm} FieldAlarm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldAlarm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FieldAlarm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.moduleId = reader.string();
                    break;
                case 2:
                    message.property = reader.string();
                    break;
                case 3:
                    message.veryLow = $root.AlarmZoneValue.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.low = $root.AlarmZoneValue.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.high = $root.AlarmZoneValue.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.veryHigh = $root.AlarmZoneValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a FieldAlarm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FieldAlarm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FieldAlarm} FieldAlarm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldAlarm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a FieldAlarm message.
         * @function verify
         * @memberof FieldAlarm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldAlarm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moduleId != null && message.hasOwnProperty("moduleId"))
                if (!$util.isString(message.moduleId))
                    return "moduleId: string expected";
            if (message.property != null && message.hasOwnProperty("property"))
                if (!$util.isString(message.property))
                    return "property: string expected";
            if (message.veryLow != null && message.hasOwnProperty("veryLow")) {
                var error = $root.AlarmZoneValue.verify(message.veryLow);
                if (error)
                    return "veryLow." + error;
            }
            if (message.low != null && message.hasOwnProperty("low")) {
                var error = $root.AlarmZoneValue.verify(message.low);
                if (error)
                    return "low." + error;
            }
            if (message.high != null && message.hasOwnProperty("high")) {
                var error = $root.AlarmZoneValue.verify(message.high);
                if (error)
                    return "high." + error;
            }
            if (message.veryHigh != null && message.hasOwnProperty("veryHigh")) {
                var error = $root.AlarmZoneValue.verify(message.veryHigh);
                if (error)
                    return "veryHigh." + error;
            }
            return null;
        };
    
        /**
         * Creates a FieldAlarm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof FieldAlarm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {FieldAlarm} FieldAlarm
         */
        FieldAlarm.fromObject = function fromObject(object) {
            if (object instanceof $root.FieldAlarm)
                return object;
            var message = new $root.FieldAlarm();
            if (object.moduleId != null)
                message.moduleId = String(object.moduleId);
            if (object.property != null)
                message.property = String(object.property);
            if (object.veryLow != null) {
                if (typeof object.veryLow !== "object")
                    throw TypeError(".FieldAlarm.veryLow: object expected");
                message.veryLow = $root.AlarmZoneValue.fromObject(object.veryLow);
            }
            if (object.low != null) {
                if (typeof object.low !== "object")
                    throw TypeError(".FieldAlarm.low: object expected");
                message.low = $root.AlarmZoneValue.fromObject(object.low);
            }
            if (object.high != null) {
                if (typeof object.high !== "object")
                    throw TypeError(".FieldAlarm.high: object expected");
                message.high = $root.AlarmZoneValue.fromObject(object.high);
            }
            if (object.veryHigh != null) {
                if (typeof object.veryHigh !== "object")
                    throw TypeError(".FieldAlarm.veryHigh: object expected");
                message.veryHigh = $root.AlarmZoneValue.fromObject(object.veryHigh);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a FieldAlarm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof FieldAlarm
         * @static
         * @param {FieldAlarm} message FieldAlarm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldAlarm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.moduleId = "";
                object.property = "";
                object.veryLow = null;
                object.low = null;
                object.high = null;
                object.veryHigh = null;
            }
            if (message.moduleId != null && message.hasOwnProperty("moduleId"))
                object.moduleId = message.moduleId;
            if (message.property != null && message.hasOwnProperty("property"))
                object.property = message.property;
            if (message.veryLow != null && message.hasOwnProperty("veryLow"))
                object.veryLow = $root.AlarmZoneValue.toObject(message.veryLow, options);
            if (message.low != null && message.hasOwnProperty("low"))
                object.low = $root.AlarmZoneValue.toObject(message.low, options);
            if (message.high != null && message.hasOwnProperty("high"))
                object.high = $root.AlarmZoneValue.toObject(message.high, options);
            if (message.veryHigh != null && message.hasOwnProperty("veryHigh"))
                object.veryHigh = $root.AlarmZoneValue.toObject(message.veryHigh, options);
            return object;
        };
    
        /**
         * Converts this FieldAlarm to JSON.
         * @function toJSON
         * @memberof FieldAlarm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldAlarm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return FieldAlarm;
    })();
    
    $root.FieldAlarmEvent = (function() {
    
        /**
         * Properties of a FieldAlarmEvent.
         * @exports IFieldAlarmEvent
         * @interface IFieldAlarmEvent
         * @property {string|null} [moduleId] FieldAlarmEvent moduleId
         * @property {string|null} [property] FieldAlarmEvent property
         * @property {AlarmZone|null} [previousZone] FieldAlarmEvent previousZone
         * @property {AlarmZone|null} [currentZone] FieldAlarmEvent currentZone
         * @property {number|null} [currentValue] FieldAlarmEvent currentValue
         * @property {number|null} [previousValue] FieldAlarmEvent previousValue
         */
    
        /**
         * Constructs a new FieldAlarmEvent.
         * @exports FieldAlarmEvent
         * @classdesc Represents a FieldAlarmEvent.
         * @implements IFieldAlarmEvent
         * @constructor
         * @param {IFieldAlarmEvent=} [properties] Properties to set
         */
        function FieldAlarmEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * FieldAlarmEvent moduleId.
         * @member {string} moduleId
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.moduleId = "";
    
        /**
         * FieldAlarmEvent property.
         * @member {string} property
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.property = "";
    
        /**
         * FieldAlarmEvent previousZone.
         * @member {AlarmZone} previousZone
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.previousZone = 0;
    
        /**
         * FieldAlarmEvent currentZone.
         * @member {AlarmZone} currentZone
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.currentZone = 0;
    
        /**
         * FieldAlarmEvent currentValue.
         * @member {number} currentValue
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.currentValue = 0;
    
        /**
         * FieldAlarmEvent previousValue.
         * @member {number} previousValue
         * @memberof FieldAlarmEvent
         * @instance
         */
        FieldAlarmEvent.prototype.previousValue = 0;
    
        /**
         * Creates a new FieldAlarmEvent instance using the specified properties.
         * @function create
         * @memberof FieldAlarmEvent
         * @static
         * @param {IFieldAlarmEvent=} [properties] Properties to set
         * @returns {FieldAlarmEvent} FieldAlarmEvent instance
         */
        FieldAlarmEvent.create = function create(properties) {
            return new FieldAlarmEvent(properties);
        };
    
        /**
         * Encodes the specified FieldAlarmEvent message. Does not implicitly {@link FieldAlarmEvent.verify|verify} messages.
         * @function encode
         * @memberof FieldAlarmEvent
         * @static
         * @param {IFieldAlarmEvent} message FieldAlarmEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldAlarmEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moduleId != null && Object.hasOwnProperty.call(message, "moduleId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.moduleId);
            if (message.property != null && Object.hasOwnProperty.call(message, "property"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.property);
            if (message.previousZone != null && Object.hasOwnProperty.call(message, "previousZone"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.previousZone);
            if (message.currentZone != null && Object.hasOwnProperty.call(message, "currentZone"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.currentZone);
            if (message.currentValue != null && Object.hasOwnProperty.call(message, "currentValue"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.currentValue);
            if (message.previousValue != null && Object.hasOwnProperty.call(message, "previousValue"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.previousValue);
            return writer;
        };
    
        /**
         * Encodes the specified FieldAlarmEvent message, length delimited. Does not implicitly {@link FieldAlarmEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof FieldAlarmEvent
         * @static
         * @param {IFieldAlarmEvent} message FieldAlarmEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldAlarmEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a FieldAlarmEvent message from the specified reader or buffer.
         * @function decode
         * @memberof FieldAlarmEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FieldAlarmEvent} FieldAlarmEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldAlarmEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FieldAlarmEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.moduleId = reader.string();
                    break;
                case 2:
                    message.property = reader.string();
                    break;
                case 3:
                    message.previousZone = reader.int32();
                    break;
                case 4:
                    message.currentZone = reader.int32();
                    break;
                case 5:
                    message.currentValue = reader.uint32();
                    break;
                case 6:
                    message.previousValue = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a FieldAlarmEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FieldAlarmEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FieldAlarmEvent} FieldAlarmEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldAlarmEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a FieldAlarmEvent message.
         * @function verify
         * @memberof FieldAlarmEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldAlarmEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moduleId != null && message.hasOwnProperty("moduleId"))
                if (!$util.isString(message.moduleId))
                    return "moduleId: string expected";
            if (message.property != null && message.hasOwnProperty("property"))
                if (!$util.isString(message.property))
                    return "property: string expected";
            if (message.previousZone != null && message.hasOwnProperty("previousZone"))
                switch (message.previousZone) {
                default:
                    return "previousZone: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.currentZone != null && message.hasOwnProperty("currentZone"))
                switch (message.currentZone) {
                default:
                    return "currentZone: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.currentValue != null && message.hasOwnProperty("currentValue"))
                if (!$util.isInteger(message.currentValue))
                    return "currentValue: integer expected";
            if (message.previousValue != null && message.hasOwnProperty("previousValue"))
                if (!$util.isInteger(message.previousValue))
                    return "previousValue: integer expected";
            return null;
        };
    
        /**
         * Creates a FieldAlarmEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof FieldAlarmEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {FieldAlarmEvent} FieldAlarmEvent
         */
        FieldAlarmEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.FieldAlarmEvent)
                return object;
            var message = new $root.FieldAlarmEvent();
            if (object.moduleId != null)
                message.moduleId = String(object.moduleId);
            if (object.property != null)
                message.property = String(object.property);
            switch (object.previousZone) {
            case "UNKNOW":
            case 0:
                message.previousZone = 0;
                break;
            case "MIDDLE":
            case 1:
                message.previousZone = 1;
                break;
            case "VERY_LOW":
            case 2:
                message.previousZone = 2;
                break;
            case "LOW":
            case 3:
                message.previousZone = 3;
                break;
            case "HIGH":
            case 4:
                message.previousZone = 4;
                break;
            case "VERY_HIGH":
            case 5:
                message.previousZone = 5;
                break;
            }
            switch (object.currentZone) {
            case "UNKNOW":
            case 0:
                message.currentZone = 0;
                break;
            case "MIDDLE":
            case 1:
                message.currentZone = 1;
                break;
            case "VERY_LOW":
            case 2:
                message.currentZone = 2;
                break;
            case "LOW":
            case 3:
                message.currentZone = 3;
                break;
            case "HIGH":
            case 4:
                message.currentZone = 4;
                break;
            case "VERY_HIGH":
            case 5:
                message.currentZone = 5;
                break;
            }
            if (object.currentValue != null)
                message.currentValue = object.currentValue >>> 0;
            if (object.previousValue != null)
                message.previousValue = object.previousValue >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a FieldAlarmEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof FieldAlarmEvent
         * @static
         * @param {FieldAlarmEvent} message FieldAlarmEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldAlarmEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.moduleId = "";
                object.property = "";
                object.previousZone = options.enums === String ? "UNKNOW" : 0;
                object.currentZone = options.enums === String ? "UNKNOW" : 0;
                object.currentValue = 0;
                object.previousValue = 0;
            }
            if (message.moduleId != null && message.hasOwnProperty("moduleId"))
                object.moduleId = message.moduleId;
            if (message.property != null && message.hasOwnProperty("property"))
                object.property = message.property;
            if (message.previousZone != null && message.hasOwnProperty("previousZone"))
                object.previousZone = options.enums === String ? $root.AlarmZone[message.previousZone] : message.previousZone;
            if (message.currentZone != null && message.hasOwnProperty("currentZone"))
                object.currentZone = options.enums === String ? $root.AlarmZone[message.currentZone] : message.currentZone;
            if (message.currentValue != null && message.hasOwnProperty("currentValue"))
                object.currentValue = message.currentValue;
            if (message.previousValue != null && message.hasOwnProperty("previousValue"))
                object.previousValue = message.previousValue;
            return object;
        };
    
        /**
         * Converts this FieldAlarmEvent to JSON.
         * @function toJSON
         * @memberof FieldAlarmEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldAlarmEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return FieldAlarmEvent;
    })();
    
    $root.GrowbeMainboardConfig = (function() {
    
        /**
         * Properties of a GrowbeMainboardConfig.
         * @exports IGrowbeMainboardConfig
         * @interface IGrowbeMainboardConfig
         * @property {number|null} [hearthBeath] GrowbeMainboardConfig hearthBeath
         */
    
        /**
         * Constructs a new GrowbeMainboardConfig.
         * @exports GrowbeMainboardConfig
         * @classdesc Represents a GrowbeMainboardConfig.
         * @implements IGrowbeMainboardConfig
         * @constructor
         * @param {IGrowbeMainboardConfig=} [properties] Properties to set
         */
        function GrowbeMainboardConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GrowbeMainboardConfig hearthBeath.
         * @member {number} hearthBeath
         * @memberof GrowbeMainboardConfig
         * @instance
         */
        GrowbeMainboardConfig.prototype.hearthBeath = 0;
    
        /**
         * Creates a new GrowbeMainboardConfig instance using the specified properties.
         * @function create
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {IGrowbeMainboardConfig=} [properties] Properties to set
         * @returns {GrowbeMainboardConfig} GrowbeMainboardConfig instance
         */
        GrowbeMainboardConfig.create = function create(properties) {
            return new GrowbeMainboardConfig(properties);
        };
    
        /**
         * Encodes the specified GrowbeMainboardConfig message. Does not implicitly {@link GrowbeMainboardConfig.verify|verify} messages.
         * @function encode
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {IGrowbeMainboardConfig} message GrowbeMainboardConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowbeMainboardConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hearthBeath != null && Object.hasOwnProperty.call(message, "hearthBeath"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hearthBeath);
            return writer;
        };
    
        /**
         * Encodes the specified GrowbeMainboardConfig message, length delimited. Does not implicitly {@link GrowbeMainboardConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {IGrowbeMainboardConfig} message GrowbeMainboardConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowbeMainboardConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GrowbeMainboardConfig message from the specified reader or buffer.
         * @function decode
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GrowbeMainboardConfig} GrowbeMainboardConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowbeMainboardConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GrowbeMainboardConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hearthBeath = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GrowbeMainboardConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GrowbeMainboardConfig} GrowbeMainboardConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowbeMainboardConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GrowbeMainboardConfig message.
         * @function verify
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrowbeMainboardConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hearthBeath != null && message.hasOwnProperty("hearthBeath"))
                if (!$util.isInteger(message.hearthBeath))
                    return "hearthBeath: integer expected";
            return null;
        };
    
        /**
         * Creates a GrowbeMainboardConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GrowbeMainboardConfig} GrowbeMainboardConfig
         */
        GrowbeMainboardConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.GrowbeMainboardConfig)
                return object;
            var message = new $root.GrowbeMainboardConfig();
            if (object.hearthBeath != null)
                message.hearthBeath = object.hearthBeath | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a GrowbeMainboardConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GrowbeMainboardConfig
         * @static
         * @param {GrowbeMainboardConfig} message GrowbeMainboardConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrowbeMainboardConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hearthBeath = 0;
            if (message.hearthBeath != null && message.hasOwnProperty("hearthBeath"))
                object.hearthBeath = message.hearthBeath;
            return object;
        };
    
        /**
         * Converts this GrowbeMainboardConfig to JSON.
         * @function toJSON
         * @memberof GrowbeMainboardConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrowbeMainboardConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GrowbeMainboardConfig;
    })();
    
    $root.HelloWord = (function() {
    
        /**
         * Properties of a HelloWord.
         * @exports IHelloWord
         * @interface IHelloWord
         * @property {string|null} [version] HelloWord version
         * @property {string|null} [cloudVersion] HelloWord cloudVersion
         * @property {string|null} [RTC] HelloWord RTC
         */
    
        /**
         * Constructs a new HelloWord.
         * @exports HelloWord
         * @classdesc Represents a HelloWord.
         * @implements IHelloWord
         * @constructor
         * @param {IHelloWord=} [properties] Properties to set
         */
        function HelloWord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * HelloWord version.
         * @member {string} version
         * @memberof HelloWord
         * @instance
         */
        HelloWord.prototype.version = "";
    
        /**
         * HelloWord cloudVersion.
         * @member {string} cloudVersion
         * @memberof HelloWord
         * @instance
         */
        HelloWord.prototype.cloudVersion = "";
    
        /**
         * HelloWord RTC.
         * @member {string} RTC
         * @memberof HelloWord
         * @instance
         */
        HelloWord.prototype.RTC = "";
    
        /**
         * Creates a new HelloWord instance using the specified properties.
         * @function create
         * @memberof HelloWord
         * @static
         * @param {IHelloWord=} [properties] Properties to set
         * @returns {HelloWord} HelloWord instance
         */
        HelloWord.create = function create(properties) {
            return new HelloWord(properties);
        };
    
        /**
         * Encodes the specified HelloWord message. Does not implicitly {@link HelloWord.verify|verify} messages.
         * @function encode
         * @memberof HelloWord
         * @static
         * @param {IHelloWord} message HelloWord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloWord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.cloudVersion != null && Object.hasOwnProperty.call(message, "cloudVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cloudVersion);
            if (message.RTC != null && Object.hasOwnProperty.call(message, "RTC"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.RTC);
            return writer;
        };
    
        /**
         * Encodes the specified HelloWord message, length delimited. Does not implicitly {@link HelloWord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HelloWord
         * @static
         * @param {IHelloWord} message HelloWord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloWord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a HelloWord message from the specified reader or buffer.
         * @function decode
         * @memberof HelloWord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HelloWord} HelloWord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloWord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HelloWord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.cloudVersion = reader.string();
                    break;
                case 3:
                    message.RTC = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a HelloWord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HelloWord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HelloWord} HelloWord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloWord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a HelloWord message.
         * @function verify
         * @memberof HelloWord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelloWord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.cloudVersion != null && message.hasOwnProperty("cloudVersion"))
                if (!$util.isString(message.cloudVersion))
                    return "cloudVersion: string expected";
            if (message.RTC != null && message.hasOwnProperty("RTC"))
                if (!$util.isString(message.RTC))
                    return "RTC: string expected";
            return null;
        };
    
        /**
         * Creates a HelloWord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HelloWord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HelloWord} HelloWord
         */
        HelloWord.fromObject = function fromObject(object) {
            if (object instanceof $root.HelloWord)
                return object;
            var message = new $root.HelloWord();
            if (object.version != null)
                message.version = String(object.version);
            if (object.cloudVersion != null)
                message.cloudVersion = String(object.cloudVersion);
            if (object.RTC != null)
                message.RTC = String(object.RTC);
            return message;
        };
    
        /**
         * Creates a plain object from a HelloWord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HelloWord
         * @static
         * @param {HelloWord} message HelloWord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HelloWord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                object.cloudVersion = "";
                object.RTC = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.cloudVersion != null && message.hasOwnProperty("cloudVersion"))
                object.cloudVersion = message.cloudVersion;
            if (message.RTC != null && message.hasOwnProperty("RTC"))
                object.RTC = message.RTC;
            return object;
        };
    
        /**
         * Converts this HelloWord to JSON.
         * @function toJSON
         * @memberof HelloWord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HelloWord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return HelloWord;
    })();
    
    $root.VersionRelease = (function() {
    
        /**
         * Properties of a VersionRelease.
         * @exports IVersionRelease
         * @interface IVersionRelease
         * @property {string|null} [version] VersionRelease version
         * @property {string|null} [channel] VersionRelease channel
         */
    
        /**
         * Constructs a new VersionRelease.
         * @exports VersionRelease
         * @classdesc Represents a VersionRelease.
         * @implements IVersionRelease
         * @constructor
         * @param {IVersionRelease=} [properties] Properties to set
         */
        function VersionRelease(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersionRelease version.
         * @member {string} version
         * @memberof VersionRelease
         * @instance
         */
        VersionRelease.prototype.version = "";
    
        /**
         * VersionRelease channel.
         * @member {string} channel
         * @memberof VersionRelease
         * @instance
         */
        VersionRelease.prototype.channel = "";
    
        /**
         * Creates a new VersionRelease instance using the specified properties.
         * @function create
         * @memberof VersionRelease
         * @static
         * @param {IVersionRelease=} [properties] Properties to set
         * @returns {VersionRelease} VersionRelease instance
         */
        VersionRelease.create = function create(properties) {
            return new VersionRelease(properties);
        };
    
        /**
         * Encodes the specified VersionRelease message. Does not implicitly {@link VersionRelease.verify|verify} messages.
         * @function encode
         * @memberof VersionRelease
         * @static
         * @param {IVersionRelease} message VersionRelease message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionRelease.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
            return writer;
        };
    
        /**
         * Encodes the specified VersionRelease message, length delimited. Does not implicitly {@link VersionRelease.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersionRelease
         * @static
         * @param {IVersionRelease} message VersionRelease message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionRelease.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersionRelease message from the specified reader or buffer.
         * @function decode
         * @memberof VersionRelease
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersionRelease} VersionRelease
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionRelease.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersionRelease();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.channel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersionRelease message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersionRelease
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersionRelease} VersionRelease
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionRelease.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersionRelease message.
         * @function verify
         * @memberof VersionRelease
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionRelease.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isString(message.channel))
                    return "channel: string expected";
            return null;
        };
    
        /**
         * Creates a VersionRelease message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersionRelease
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersionRelease} VersionRelease
         */
        VersionRelease.fromObject = function fromObject(object) {
            if (object instanceof $root.VersionRelease)
                return object;
            var message = new $root.VersionRelease();
            if (object.version != null)
                message.version = String(object.version);
            if (object.channel != null)
                message.channel = String(object.channel);
            return message;
        };
    
        /**
         * Creates a plain object from a VersionRelease message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersionRelease
         * @static
         * @param {VersionRelease} message VersionRelease
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionRelease.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                object.channel = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            return object;
        };
    
        /**
         * Converts this VersionRelease to JSON.
         * @function toJSON
         * @memberof VersionRelease
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionRelease.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return VersionRelease;
    })();
    
    $root.UpdateExecute = (function() {
    
        /**
         * Properties of an UpdateExecute.
         * @exports IUpdateExecute
         * @interface IUpdateExecute
         * @property {string|null} [version] UpdateExecute version
         * @property {boolean|null} [restarted] UpdateExecute restarted
         */
    
        /**
         * Constructs a new UpdateExecute.
         * @exports UpdateExecute
         * @classdesc Represents an UpdateExecute.
         * @implements IUpdateExecute
         * @constructor
         * @param {IUpdateExecute=} [properties] Properties to set
         */
        function UpdateExecute(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * UpdateExecute version.
         * @member {string} version
         * @memberof UpdateExecute
         * @instance
         */
        UpdateExecute.prototype.version = "";
    
        /**
         * UpdateExecute restarted.
         * @member {boolean} restarted
         * @memberof UpdateExecute
         * @instance
         */
        UpdateExecute.prototype.restarted = false;
    
        /**
         * Creates a new UpdateExecute instance using the specified properties.
         * @function create
         * @memberof UpdateExecute
         * @static
         * @param {IUpdateExecute=} [properties] Properties to set
         * @returns {UpdateExecute} UpdateExecute instance
         */
        UpdateExecute.create = function create(properties) {
            return new UpdateExecute(properties);
        };
    
        /**
         * Encodes the specified UpdateExecute message. Does not implicitly {@link UpdateExecute.verify|verify} messages.
         * @function encode
         * @memberof UpdateExecute
         * @static
         * @param {IUpdateExecute} message UpdateExecute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateExecute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.restarted != null && Object.hasOwnProperty.call(message, "restarted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.restarted);
            return writer;
        };
    
        /**
         * Encodes the specified UpdateExecute message, length delimited. Does not implicitly {@link UpdateExecute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof UpdateExecute
         * @static
         * @param {IUpdateExecute} message UpdateExecute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateExecute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an UpdateExecute message from the specified reader or buffer.
         * @function decode
         * @memberof UpdateExecute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UpdateExecute} UpdateExecute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateExecute.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateExecute();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.restarted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an UpdateExecute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UpdateExecute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UpdateExecute} UpdateExecute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateExecute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an UpdateExecute message.
         * @function verify
         * @memberof UpdateExecute
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateExecute.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.restarted != null && message.hasOwnProperty("restarted"))
                if (typeof message.restarted !== "boolean")
                    return "restarted: boolean expected";
            return null;
        };
    
        /**
         * Creates an UpdateExecute message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof UpdateExecute
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {UpdateExecute} UpdateExecute
         */
        UpdateExecute.fromObject = function fromObject(object) {
            if (object instanceof $root.UpdateExecute)
                return object;
            var message = new $root.UpdateExecute();
            if (object.version != null)
                message.version = String(object.version);
            if (object.restarted != null)
                message.restarted = Boolean(object.restarted);
            return message;
        };
    
        /**
         * Creates a plain object from an UpdateExecute message. Also converts values to other types if specified.
         * @function toObject
         * @memberof UpdateExecute
         * @static
         * @param {UpdateExecute} message UpdateExecute
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateExecute.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                object.restarted = false;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.restarted != null && message.hasOwnProperty("restarted"))
                object.restarted = message.restarted;
            return object;
        };
    
        /**
         * Converts this UpdateExecute to JSON.
         * @function toJSON
         * @memberof UpdateExecute
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateExecute.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return UpdateExecute;
    })();
    
    $root.RestartRequest = (function() {
    
        /**
         * Properties of a RestartRequest.
         * @exports IRestartRequest
         * @interface IRestartRequest
         */
    
        /**
         * Constructs a new RestartRequest.
         * @exports RestartRequest
         * @classdesc Represents a RestartRequest.
         * @implements IRestartRequest
         * @constructor
         * @param {IRestartRequest=} [properties] Properties to set
         */
        function RestartRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new RestartRequest instance using the specified properties.
         * @function create
         * @memberof RestartRequest
         * @static
         * @param {IRestartRequest=} [properties] Properties to set
         * @returns {RestartRequest} RestartRequest instance
         */
        RestartRequest.create = function create(properties) {
            return new RestartRequest(properties);
        };
    
        /**
         * Encodes the specified RestartRequest message. Does not implicitly {@link RestartRequest.verify|verify} messages.
         * @function encode
         * @memberof RestartRequest
         * @static
         * @param {IRestartRequest} message RestartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestartRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified RestartRequest message, length delimited. Does not implicitly {@link RestartRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RestartRequest
         * @static
         * @param {IRestartRequest} message RestartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestartRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RestartRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RestartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RestartRequest} RestartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestartRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RestartRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RestartRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RestartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RestartRequest} RestartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestartRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RestartRequest message.
         * @function verify
         * @memberof RestartRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestartRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a RestartRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RestartRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RestartRequest} RestartRequest
         */
        RestartRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RestartRequest)
                return object;
            return new $root.RestartRequest();
        };
    
        /**
         * Creates a plain object from a RestartRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RestartRequest
         * @static
         * @param {RestartRequest} message RestartRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestartRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this RestartRequest to JSON.
         * @function toJSON
         * @memberof RestartRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestartRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RestartRequest;
    })();
    
    $root.LocalConnection = (function() {
    
        /**
         * Properties of a LocalConnection.
         * @exports ILocalConnection
         * @interface ILocalConnection
         * @property {string|null} [ssid] LocalConnection ssid
         * @property {number|null} [signalLevel] LocalConnection signalLevel
         * @property {string|null} [ipAddr] LocalConnection ipAddr
         */
    
        /**
         * Constructs a new LocalConnection.
         * @exports LocalConnection
         * @classdesc Represents a LocalConnection.
         * @implements ILocalConnection
         * @constructor
         * @param {ILocalConnection=} [properties] Properties to set
         */
        function LocalConnection(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * LocalConnection ssid.
         * @member {string} ssid
         * @memberof LocalConnection
         * @instance
         */
        LocalConnection.prototype.ssid = "";
    
        /**
         * LocalConnection signalLevel.
         * @member {number} signalLevel
         * @memberof LocalConnection
         * @instance
         */
        LocalConnection.prototype.signalLevel = 0;
    
        /**
         * LocalConnection ipAddr.
         * @member {string} ipAddr
         * @memberof LocalConnection
         * @instance
         */
        LocalConnection.prototype.ipAddr = "";
    
        /**
         * Creates a new LocalConnection instance using the specified properties.
         * @function create
         * @memberof LocalConnection
         * @static
         * @param {ILocalConnection=} [properties] Properties to set
         * @returns {LocalConnection} LocalConnection instance
         */
        LocalConnection.create = function create(properties) {
            return new LocalConnection(properties);
        };
    
        /**
         * Encodes the specified LocalConnection message. Does not implicitly {@link LocalConnection.verify|verify} messages.
         * @function encode
         * @memberof LocalConnection
         * @static
         * @param {ILocalConnection} message LocalConnection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalConnection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
            if (message.signalLevel != null && Object.hasOwnProperty.call(message, "signalLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.signalLevel);
            if (message.ipAddr != null && Object.hasOwnProperty.call(message, "ipAddr"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ipAddr);
            return writer;
        };
    
        /**
         * Encodes the specified LocalConnection message, length delimited. Does not implicitly {@link LocalConnection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof LocalConnection
         * @static
         * @param {ILocalConnection} message LocalConnection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalConnection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a LocalConnection message from the specified reader or buffer.
         * @function decode
         * @memberof LocalConnection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {LocalConnection} LocalConnection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalConnection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LocalConnection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssid = reader.string();
                    break;
                case 2:
                    message.signalLevel = reader.int32();
                    break;
                case 3:
                    message.ipAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a LocalConnection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof LocalConnection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {LocalConnection} LocalConnection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalConnection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a LocalConnection message.
         * @function verify
         * @memberof LocalConnection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocalConnection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssid != null && message.hasOwnProperty("ssid"))
                if (!$util.isString(message.ssid))
                    return "ssid: string expected";
            if (message.signalLevel != null && message.hasOwnProperty("signalLevel"))
                if (!$util.isInteger(message.signalLevel))
                    return "signalLevel: integer expected";
            if (message.ipAddr != null && message.hasOwnProperty("ipAddr"))
                if (!$util.isString(message.ipAddr))
                    return "ipAddr: string expected";
            return null;
        };
    
        /**
         * Creates a LocalConnection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof LocalConnection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {LocalConnection} LocalConnection
         */
        LocalConnection.fromObject = function fromObject(object) {
            if (object instanceof $root.LocalConnection)
                return object;
            var message = new $root.LocalConnection();
            if (object.ssid != null)
                message.ssid = String(object.ssid);
            if (object.signalLevel != null)
                message.signalLevel = object.signalLevel | 0;
            if (object.ipAddr != null)
                message.ipAddr = String(object.ipAddr);
            return message;
        };
    
        /**
         * Creates a plain object from a LocalConnection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof LocalConnection
         * @static
         * @param {LocalConnection} message LocalConnection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocalConnection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ssid = "";
                object.signalLevel = 0;
                object.ipAddr = "";
            }
            if (message.ssid != null && message.hasOwnProperty("ssid"))
                object.ssid = message.ssid;
            if (message.signalLevel != null && message.hasOwnProperty("signalLevel"))
                object.signalLevel = message.signalLevel;
            if (message.ipAddr != null && message.hasOwnProperty("ipAddr"))
                object.ipAddr = message.ipAddr;
            return object;
        };
    
        /**
         * Converts this LocalConnection to JSON.
         * @function toJSON
         * @memberof LocalConnection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocalConnection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return LocalConnection;
    })();
    
    $root.GrowbeMessage = (function() {
    
        /**
         * Properties of a GrowbeMessage.
         * @exports IGrowbeMessage
         * @interface IGrowbeMessage
         * @property {string|null} [topic] GrowbeMessage topic
         * @property {number|null} [messageType] GrowbeMessage messageType
         * @property {Uint8Array|null} [body] GrowbeMessage body
         */
    
        /**
         * Constructs a new GrowbeMessage.
         * @exports GrowbeMessage
         * @classdesc Represents a GrowbeMessage.
         * @implements IGrowbeMessage
         * @constructor
         * @param {IGrowbeMessage=} [properties] Properties to set
         */
        function GrowbeMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GrowbeMessage topic.
         * @member {string} topic
         * @memberof GrowbeMessage
         * @instance
         */
        GrowbeMessage.prototype.topic = "";
    
        /**
         * GrowbeMessage messageType.
         * @member {number} messageType
         * @memberof GrowbeMessage
         * @instance
         */
        GrowbeMessage.prototype.messageType = 0;
    
        /**
         * GrowbeMessage body.
         * @member {Uint8Array} body
         * @memberof GrowbeMessage
         * @instance
         */
        GrowbeMessage.prototype.body = $util.newBuffer([]);
    
        /**
         * Creates a new GrowbeMessage instance using the specified properties.
         * @function create
         * @memberof GrowbeMessage
         * @static
         * @param {IGrowbeMessage=} [properties] Properties to set
         * @returns {GrowbeMessage} GrowbeMessage instance
         */
        GrowbeMessage.create = function create(properties) {
            return new GrowbeMessage(properties);
        };
    
        /**
         * Encodes the specified GrowbeMessage message. Does not implicitly {@link GrowbeMessage.verify|verify} messages.
         * @function encode
         * @memberof GrowbeMessage
         * @static
         * @param {IGrowbeMessage} message GrowbeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowbeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
            if (message.messageType != null && Object.hasOwnProperty.call(message, "messageType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messageType);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.body);
            return writer;
        };
    
        /**
         * Encodes the specified GrowbeMessage message, length delimited. Does not implicitly {@link GrowbeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GrowbeMessage
         * @static
         * @param {IGrowbeMessage} message GrowbeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowbeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GrowbeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof GrowbeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GrowbeMessage} GrowbeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowbeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GrowbeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.topic = reader.string();
                    break;
                case 2:
                    message.messageType = reader.int32();
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GrowbeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GrowbeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GrowbeMessage} GrowbeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowbeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GrowbeMessage message.
         * @function verify
         * @memberof GrowbeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrowbeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.topic != null && message.hasOwnProperty("topic"))
                if (!$util.isString(message.topic))
                    return "topic: string expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                if (!$util.isInteger(message.messageType))
                    return "messageType: integer expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };
    
        /**
         * Creates a GrowbeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GrowbeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GrowbeMessage} GrowbeMessage
         */
        GrowbeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.GrowbeMessage)
                return object;
            var message = new $root.GrowbeMessage();
            if (object.topic != null)
                message.topic = String(object.topic);
            if (object.messageType != null)
                message.messageType = object.messageType | 0;
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };
    
        /**
         * Creates a plain object from a GrowbeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GrowbeMessage
         * @static
         * @param {GrowbeMessage} message GrowbeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrowbeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.topic = "";
                object.messageType = 0;
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.topic != null && message.hasOwnProperty("topic"))
                object.topic = message.topic;
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = message.messageType;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };
    
        /**
         * Converts this GrowbeMessage to JSON.
         * @function toJSON
         * @memberof GrowbeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrowbeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GrowbeMessage;
    })();
    
    $root.HearthBeath = (function() {
    
        /**
         * Properties of a HearthBeath.
         * @exports IHearthBeath
         * @interface IHearthBeath
         * @property {string|null} [rtc] HearthBeath rtc
         */
    
        /**
         * Constructs a new HearthBeath.
         * @exports HearthBeath
         * @classdesc Represents a HearthBeath.
         * @implements IHearthBeath
         * @constructor
         * @param {IHearthBeath=} [properties] Properties to set
         */
        function HearthBeath(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * HearthBeath rtc.
         * @member {string} rtc
         * @memberof HearthBeath
         * @instance
         */
        HearthBeath.prototype.rtc = "";
    
        /**
         * Creates a new HearthBeath instance using the specified properties.
         * @function create
         * @memberof HearthBeath
         * @static
         * @param {IHearthBeath=} [properties] Properties to set
         * @returns {HearthBeath} HearthBeath instance
         */
        HearthBeath.create = function create(properties) {
            return new HearthBeath(properties);
        };
    
        /**
         * Encodes the specified HearthBeath message. Does not implicitly {@link HearthBeath.verify|verify} messages.
         * @function encode
         * @memberof HearthBeath
         * @static
         * @param {IHearthBeath} message HearthBeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearthBeath.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rtc != null && Object.hasOwnProperty.call(message, "rtc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.rtc);
            return writer;
        };
    
        /**
         * Encodes the specified HearthBeath message, length delimited. Does not implicitly {@link HearthBeath.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HearthBeath
         * @static
         * @param {IHearthBeath} message HearthBeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearthBeath.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a HearthBeath message from the specified reader or buffer.
         * @function decode
         * @memberof HearthBeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HearthBeath} HearthBeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearthBeath.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HearthBeath();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.rtc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a HearthBeath message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HearthBeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HearthBeath} HearthBeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearthBeath.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a HearthBeath message.
         * @function verify
         * @memberof HearthBeath
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HearthBeath.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rtc != null && message.hasOwnProperty("rtc"))
                if (!$util.isString(message.rtc))
                    return "rtc: string expected";
            return null;
        };
    
        /**
         * Creates a HearthBeath message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HearthBeath
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HearthBeath} HearthBeath
         */
        HearthBeath.fromObject = function fromObject(object) {
            if (object instanceof $root.HearthBeath)
                return object;
            var message = new $root.HearthBeath();
            if (object.rtc != null)
                message.rtc = String(object.rtc);
            return message;
        };
    
        /**
         * Creates a plain object from a HearthBeath message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HearthBeath
         * @static
         * @param {HearthBeath} message HearthBeath
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HearthBeath.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rtc = "";
            if (message.rtc != null && message.hasOwnProperty("rtc"))
                object.rtc = message.rtc;
            return object;
        };
    
        /**
         * Converts this HearthBeath to JSON.
         * @function toJSON
         * @memberof HearthBeath
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HearthBeath.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return HearthBeath;
    })();
    
    $root.Log = (function() {
    
        /**
         * Properties of a Log.
         * @exports ILog
         * @interface ILog
         * @property {number|null} [timestamp] Log timestamp
         * @property {string|null} [log] Log log
         */
    
        /**
         * Constructs a new Log.
         * @exports Log
         * @classdesc Represents a Log.
         * @implements ILog
         * @constructor
         * @param {ILog=} [properties] Properties to set
         */
        function Log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Log timestamp.
         * @member {number} timestamp
         * @memberof Log
         * @instance
         */
        Log.prototype.timestamp = 0;
    
        /**
         * Log log.
         * @member {string} log
         * @memberof Log
         * @instance
         */
        Log.prototype.log = "";
    
        /**
         * Creates a new Log instance using the specified properties.
         * @function create
         * @memberof Log
         * @static
         * @param {ILog=} [properties] Properties to set
         * @returns {Log} Log instance
         */
        Log.create = function create(properties) {
            return new Log(properties);
        };
    
        /**
         * Encodes the specified Log message. Does not implicitly {@link Log.verify|verify} messages.
         * @function encode
         * @memberof Log
         * @static
         * @param {ILog} message Log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timestamp);
            if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.log);
            return writer;
        };
    
        /**
         * Encodes the specified Log message, length delimited. Does not implicitly {@link Log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Log
         * @static
         * @param {ILog} message Log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Log message from the specified reader or buffer.
         * @function decode
         * @memberof Log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Log} Log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int32();
                    break;
                case 2:
                    message.log = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a Log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Log} Log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Log message.
         * @function verify
         * @memberof Log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.log != null && message.hasOwnProperty("log"))
                if (!$util.isString(message.log))
                    return "log: string expected";
            return null;
        };
    
        /**
         * Creates a Log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Log} Log
         */
        Log.fromObject = function fromObject(object) {
            if (object instanceof $root.Log)
                return object;
            var message = new $root.Log();
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            if (object.log != null)
                message.log = String(object.log);
            return message;
        };
    
        /**
         * Creates a plain object from a Log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Log
         * @static
         * @param {Log} message Log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.timestamp = 0;
                object.log = "";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.log != null && message.hasOwnProperty("log"))
                object.log = message.log;
            return object;
        };
    
        /**
         * Converts this Log to JSON.
         * @function toJSON
         * @memberof Log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return Log;
    })();
    
    /**
     * ActionCode enum.
     * @exports ActionCode
     * @enum {string}
     * @property {number} PARSING=0 PARSING value
     * @property {number} MODULE_CONFIG=1 MODULE_CONFIG value
     * @property {number} MAINBOARD_CONFIG=2 MAINBOARD_CONFIG value
     * @property {number} RTC_SET=3 RTC_SET value
     * @property {number} SYNC_REQUEST=4 SYNC_REQUEST value
     * @property {number} ADD_ALARM=10 ADD_ALARM value
     * @property {number} REMOVE_ALARM=11 REMOVE_ALARM value
     * @property {number} RESTART=12 RESTART value
     */
    $root.ActionCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PARSING"] = 0;
        values[valuesById[1] = "MODULE_CONFIG"] = 1;
        values[valuesById[2] = "MAINBOARD_CONFIG"] = 2;
        values[valuesById[3] = "RTC_SET"] = 3;
        values[valuesById[4] = "SYNC_REQUEST"] = 4;
        values[valuesById[10] = "ADD_ALARM"] = 10;
        values[valuesById[11] = "REMOVE_ALARM"] = 11;
        values[valuesById[12] = "RESTART"] = 12;
        return values;
    })();
    
    $root.ActionResponse = (function() {
    
        /**
         * Properties of an ActionResponse.
         * @exports IActionResponse
         * @interface IActionResponse
         * @property {ActionCode|null} [action] ActionResponse action
         * @property {number|null} [status] ActionResponse status
         * @property {string|null} [msg] ActionResponse msg
         */
    
        /**
         * Constructs a new ActionResponse.
         * @exports ActionResponse
         * @classdesc Represents an ActionResponse.
         * @implements IActionResponse
         * @constructor
         * @param {IActionResponse=} [properties] Properties to set
         */
        function ActionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ActionResponse action.
         * @member {ActionCode} action
         * @memberof ActionResponse
         * @instance
         */
        ActionResponse.prototype.action = 0;
    
        /**
         * ActionResponse status.
         * @member {number} status
         * @memberof ActionResponse
         * @instance
         */
        ActionResponse.prototype.status = 0;
    
        /**
         * ActionResponse msg.
         * @member {string} msg
         * @memberof ActionResponse
         * @instance
         */
        ActionResponse.prototype.msg = "";
    
        /**
         * Creates a new ActionResponse instance using the specified properties.
         * @function create
         * @memberof ActionResponse
         * @static
         * @param {IActionResponse=} [properties] Properties to set
         * @returns {ActionResponse} ActionResponse instance
         */
        ActionResponse.create = function create(properties) {
            return new ActionResponse(properties);
        };
    
        /**
         * Encodes the specified ActionResponse message. Does not implicitly {@link ActionResponse.verify|verify} messages.
         * @function encode
         * @memberof ActionResponse
         * @static
         * @param {IActionResponse} message ActionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.status);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msg);
            return writer;
        };
    
        /**
         * Encodes the specified ActionResponse message, length delimited. Does not implicitly {@link ActionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ActionResponse
         * @static
         * @param {IActionResponse} message ActionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an ActionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ActionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ActionResponse} ActionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.status = reader.uint32();
                    break;
                case 3:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an ActionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ActionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ActionResponse} ActionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an ActionResponse message.
         * @function verify
         * @memberof ActionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };
    
        /**
         * Creates an ActionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ActionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ActionResponse} ActionResponse
         */
        ActionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ActionResponse)
                return object;
            var message = new $root.ActionResponse();
            switch (object.action) {
            case "PARSING":
            case 0:
                message.action = 0;
                break;
            case "MODULE_CONFIG":
            case 1:
                message.action = 1;
                break;
            case "MAINBOARD_CONFIG":
            case 2:
                message.action = 2;
                break;
            case "RTC_SET":
            case 3:
                message.action = 3;
                break;
            case "SYNC_REQUEST":
            case 4:
                message.action = 4;
                break;
            case "ADD_ALARM":
            case 10:
                message.action = 10;
                break;
            case "REMOVE_ALARM":
            case 11:
                message.action = 11;
                break;
            case "RESTART":
            case 12:
                message.action = 12;
                break;
            }
            if (object.status != null)
                message.status = object.status >>> 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };
    
        /**
         * Creates a plain object from an ActionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ActionResponse
         * @static
         * @param {ActionResponse} message ActionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "PARSING" : 0;
                object.status = 0;
                object.msg = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.ActionCode[message.action] : message.action;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };
    
        /**
         * Converts this ActionResponse to JSON.
         * @function toJSON
         * @memberof ActionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ActionResponse;
    })();
    
    $root.RTCTime = (function() {
    
        /**
         * Properties of a RTCTime.
         * @exports IRTCTime
         * @interface IRTCTime
         * @property {number|null} [second] RTCTime second
         * @property {number|null} [minute] RTCTime minute
         * @property {number|null} [hour] RTCTime hour
         * @property {number|null} [day] RTCTime day
         * @property {number|null} [month] RTCTime month
         * @property {number|null} [year] RTCTime year
         * @property {string|null} [tz] RTCTime tz
         */
    
        /**
         * Constructs a new RTCTime.
         * @exports RTCTime
         * @classdesc Represents a RTCTime.
         * @implements IRTCTime
         * @constructor
         * @param {IRTCTime=} [properties] Properties to set
         */
        function RTCTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RTCTime second.
         * @member {number} second
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.second = 0;
    
        /**
         * RTCTime minute.
         * @member {number} minute
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.minute = 0;
    
        /**
         * RTCTime hour.
         * @member {number} hour
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.hour = 0;
    
        /**
         * RTCTime day.
         * @member {number} day
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.day = 0;
    
        /**
         * RTCTime month.
         * @member {number} month
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.month = 0;
    
        /**
         * RTCTime year.
         * @member {number} year
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.year = 0;
    
        /**
         * RTCTime tz.
         * @member {string} tz
         * @memberof RTCTime
         * @instance
         */
        RTCTime.prototype.tz = "";
    
        /**
         * Creates a new RTCTime instance using the specified properties.
         * @function create
         * @memberof RTCTime
         * @static
         * @param {IRTCTime=} [properties] Properties to set
         * @returns {RTCTime} RTCTime instance
         */
        RTCTime.create = function create(properties) {
            return new RTCTime(properties);
        };
    
        /**
         * Encodes the specified RTCTime message. Does not implicitly {@link RTCTime.verify|verify} messages.
         * @function encode
         * @memberof RTCTime
         * @static
         * @param {IRTCTime} message RTCTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RTCTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.second != null && Object.hasOwnProperty.call(message, "second"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.second);
            if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.minute);
            if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hour);
            if (message.day != null && Object.hasOwnProperty.call(message, "day"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.day);
            if (message.month != null && Object.hasOwnProperty.call(message, "month"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.month);
            if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.year);
            if (message.tz != null && Object.hasOwnProperty.call(message, "tz"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.tz);
            return writer;
        };
    
        /**
         * Encodes the specified RTCTime message, length delimited. Does not implicitly {@link RTCTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RTCTime
         * @static
         * @param {IRTCTime} message RTCTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RTCTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RTCTime message from the specified reader or buffer.
         * @function decode
         * @memberof RTCTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RTCTime} RTCTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RTCTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RTCTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.second = reader.uint32();
                    break;
                case 2:
                    message.minute = reader.uint32();
                    break;
                case 3:
                    message.hour = reader.uint32();
                    break;
                case 4:
                    message.day = reader.uint32();
                    break;
                case 5:
                    message.month = reader.uint32();
                    break;
                case 6:
                    message.year = reader.uint32();
                    break;
                case 7:
                    message.tz = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RTCTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RTCTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RTCTime} RTCTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RTCTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RTCTime message.
         * @function verify
         * @memberof RTCTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RTCTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.second != null && message.hasOwnProperty("second"))
                if (!$util.isInteger(message.second))
                    return "second: integer expected";
            if (message.minute != null && message.hasOwnProperty("minute"))
                if (!$util.isInteger(message.minute))
                    return "minute: integer expected";
            if (message.hour != null && message.hasOwnProperty("hour"))
                if (!$util.isInteger(message.hour))
                    return "hour: integer expected";
            if (message.day != null && message.hasOwnProperty("day"))
                if (!$util.isInteger(message.day))
                    return "day: integer expected";
            if (message.month != null && message.hasOwnProperty("month"))
                if (!$util.isInteger(message.month))
                    return "month: integer expected";
            if (message.year != null && message.hasOwnProperty("year"))
                if (!$util.isInteger(message.year))
                    return "year: integer expected";
            if (message.tz != null && message.hasOwnProperty("tz"))
                if (!$util.isString(message.tz))
                    return "tz: string expected";
            return null;
        };
    
        /**
         * Creates a RTCTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RTCTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RTCTime} RTCTime
         */
        RTCTime.fromObject = function fromObject(object) {
            if (object instanceof $root.RTCTime)
                return object;
            var message = new $root.RTCTime();
            if (object.second != null)
                message.second = object.second >>> 0;
            if (object.minute != null)
                message.minute = object.minute >>> 0;
            if (object.hour != null)
                message.hour = object.hour >>> 0;
            if (object.day != null)
                message.day = object.day >>> 0;
            if (object.month != null)
                message.month = object.month >>> 0;
            if (object.year != null)
                message.year = object.year >>> 0;
            if (object.tz != null)
                message.tz = String(object.tz);
            return message;
        };
    
        /**
         * Creates a plain object from a RTCTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RTCTime
         * @static
         * @param {RTCTime} message RTCTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RTCTime.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.second = 0;
                object.minute = 0;
                object.hour = 0;
                object.day = 0;
                object.month = 0;
                object.year = 0;
                object.tz = "";
            }
            if (message.second != null && message.hasOwnProperty("second"))
                object.second = message.second;
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.hour != null && message.hasOwnProperty("hour"))
                object.hour = message.hour;
            if (message.day != null && message.hasOwnProperty("day"))
                object.day = message.day;
            if (message.month != null && message.hasOwnProperty("month"))
                object.month = message.month;
            if (message.year != null && message.hasOwnProperty("year"))
                object.year = message.year;
            if (message.tz != null && message.hasOwnProperty("tz"))
                object.tz = message.tz;
            return object;
        };
    
        /**
         * Converts this RTCTime to JSON.
         * @function toJSON
         * @memberof RTCTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RTCTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RTCTime;
    })();
    
    $root.ModuleData = (function() {
    
        /**
         * Properties of a ModuleData.
         * @exports IModuleData
         * @interface IModuleData
         * @property {string|null} [id] ModuleData id
         * @property {string|null} [name] ModuleData name
         * @property {number|null} [readCount] ModuleData readCount
         * @property {string|null} [boardVersion] ModuleData boardVersion
         * @property {boolean|null} [plug] ModuleData plug
         * @property {number|null} [atIndex] ModuleData atIndex
         */
    
        /**
         * Constructs a new ModuleData.
         * @exports ModuleData
         * @classdesc Represents a ModuleData.
         * @implements IModuleData
         * @constructor
         * @param {IModuleData=} [properties] Properties to set
         */
        function ModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ModuleData id.
         * @member {string} id
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.id = "";
    
        /**
         * ModuleData name.
         * @member {string} name
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.name = "";
    
        /**
         * ModuleData readCount.
         * @member {number} readCount
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.readCount = 0;
    
        /**
         * ModuleData boardVersion.
         * @member {string} boardVersion
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.boardVersion = "";
    
        /**
         * ModuleData plug.
         * @member {boolean} plug
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.plug = false;
    
        /**
         * ModuleData atIndex.
         * @member {number} atIndex
         * @memberof ModuleData
         * @instance
         */
        ModuleData.prototype.atIndex = 0;
    
        /**
         * Creates a new ModuleData instance using the specified properties.
         * @function create
         * @memberof ModuleData
         * @static
         * @param {IModuleData=} [properties] Properties to set
         * @returns {ModuleData} ModuleData instance
         */
        ModuleData.create = function create(properties) {
            return new ModuleData(properties);
        };
    
        /**
         * Encodes the specified ModuleData message. Does not implicitly {@link ModuleData.verify|verify} messages.
         * @function encode
         * @memberof ModuleData
         * @static
         * @param {IModuleData} message ModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.readCount != null && Object.hasOwnProperty.call(message, "readCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.readCount);
            if (message.boardVersion != null && Object.hasOwnProperty.call(message, "boardVersion"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.boardVersion);
            if (message.plug != null && Object.hasOwnProperty.call(message, "plug"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.plug);
            if (message.atIndex != null && Object.hasOwnProperty.call(message, "atIndex"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.atIndex);
            return writer;
        };
    
        /**
         * Encodes the specified ModuleData message, length delimited. Does not implicitly {@link ModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ModuleData
         * @static
         * @param {IModuleData} message ModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof ModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ModuleData} ModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 4:
                    message.readCount = reader.int32();
                    break;
                case 5:
                    message.boardVersion = reader.string();
                    break;
                case 6:
                    message.plug = reader.bool();
                    break;
                case 7:
                    message.atIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ModuleData} ModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ModuleData message.
         * @function verify
         * @memberof ModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                if (!$util.isInteger(message.readCount))
                    return "readCount: integer expected";
            if (message.boardVersion != null && message.hasOwnProperty("boardVersion"))
                if (!$util.isString(message.boardVersion))
                    return "boardVersion: string expected";
            if (message.plug != null && message.hasOwnProperty("plug"))
                if (typeof message.plug !== "boolean")
                    return "plug: boolean expected";
            if (message.atIndex != null && message.hasOwnProperty("atIndex"))
                if (!$util.isInteger(message.atIndex))
                    return "atIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a ModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ModuleData} ModuleData
         */
        ModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.ModuleData)
                return object;
            var message = new $root.ModuleData();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.readCount != null)
                message.readCount = object.readCount | 0;
            if (object.boardVersion != null)
                message.boardVersion = String(object.boardVersion);
            if (object.plug != null)
                message.plug = Boolean(object.plug);
            if (object.atIndex != null)
                message.atIndex = object.atIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ModuleData
         * @static
         * @param {ModuleData} message ModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.readCount = 0;
                object.boardVersion = "";
                object.plug = false;
                object.atIndex = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                object.readCount = message.readCount;
            if (message.boardVersion != null && message.hasOwnProperty("boardVersion"))
                object.boardVersion = message.boardVersion;
            if (message.plug != null && message.hasOwnProperty("plug"))
                object.plug = message.plug;
            if (message.atIndex != null && message.hasOwnProperty("atIndex"))
                object.atIndex = message.atIndex;
            return object;
        };
    
        /**
         * Converts this ModuleData to JSON.
         * @function toJSON
         * @memberof ModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ModuleData;
    })();
    
    $root.THLModuleData = (function() {
    
        /**
         * Properties of a THLModuleData.
         * @exports ITHLModuleData
         * @interface ITHLModuleData
         * @property {number|null} [humidity] THLModuleData humidity
         * @property {number|null} [airTemperature] THLModuleData airTemperature
         * @property {number|null} [timestamp] THLModuleData timestamp
         */
    
        /**
         * Constructs a new THLModuleData.
         * @exports THLModuleData
         * @classdesc Represents a THLModuleData.
         * @implements ITHLModuleData
         * @constructor
         * @param {ITHLModuleData=} [properties] Properties to set
         */
        function THLModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * THLModuleData humidity.
         * @member {number} humidity
         * @memberof THLModuleData
         * @instance
         */
        THLModuleData.prototype.humidity = 0;
    
        /**
         * THLModuleData airTemperature.
         * @member {number} airTemperature
         * @memberof THLModuleData
         * @instance
         */
        THLModuleData.prototype.airTemperature = 0;
    
        /**
         * THLModuleData timestamp.
         * @member {number} timestamp
         * @memberof THLModuleData
         * @instance
         */
        THLModuleData.prototype.timestamp = 0;
    
        /**
         * Creates a new THLModuleData instance using the specified properties.
         * @function create
         * @memberof THLModuleData
         * @static
         * @param {ITHLModuleData=} [properties] Properties to set
         * @returns {THLModuleData} THLModuleData instance
         */
        THLModuleData.create = function create(properties) {
            return new THLModuleData(properties);
        };
    
        /**
         * Encodes the specified THLModuleData message. Does not implicitly {@link THLModuleData.verify|verify} messages.
         * @function encode
         * @memberof THLModuleData
         * @static
         * @param {ITHLModuleData} message THLModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        THLModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.humidity != null && Object.hasOwnProperty.call(message, "humidity"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.humidity);
            if (message.airTemperature != null && Object.hasOwnProperty.call(message, "airTemperature"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.airTemperature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified THLModuleData message, length delimited. Does not implicitly {@link THLModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof THLModuleData
         * @static
         * @param {ITHLModuleData} message THLModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        THLModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a THLModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof THLModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {THLModuleData} THLModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        THLModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.THLModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.humidity = reader.float();
                    break;
                case 3:
                    message.airTemperature = reader.float();
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a THLModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof THLModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {THLModuleData} THLModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        THLModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a THLModuleData message.
         * @function verify
         * @memberof THLModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        THLModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.humidity != null && message.hasOwnProperty("humidity"))
                if (typeof message.humidity !== "number")
                    return "humidity: number expected";
            if (message.airTemperature != null && message.hasOwnProperty("airTemperature"))
                if (typeof message.airTemperature !== "number")
                    return "airTemperature: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a THLModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof THLModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {THLModuleData} THLModuleData
         */
        THLModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.THLModuleData)
                return object;
            var message = new $root.THLModuleData();
            if (object.humidity != null)
                message.humidity = Number(object.humidity);
            if (object.airTemperature != null)
                message.airTemperature = Number(object.airTemperature);
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a THLModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof THLModuleData
         * @static
         * @param {THLModuleData} message THLModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        THLModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.humidity = 0;
                object.airTemperature = 0;
                object.timestamp = 0;
            }
            if (message.humidity != null && message.hasOwnProperty("humidity"))
                object.humidity = options.json && !isFinite(message.humidity) ? String(message.humidity) : message.humidity;
            if (message.airTemperature != null && message.hasOwnProperty("airTemperature"))
                object.airTemperature = options.json && !isFinite(message.airTemperature) ? String(message.airTemperature) : message.airTemperature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this THLModuleData to JSON.
         * @function toJSON
         * @memberof THLModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        THLModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return THLModuleData;
    })();
    
    $root.SOILModuleData = (function() {
    
        /**
         * Properties of a SOILModuleData.
         * @exports ISOILModuleData
         * @interface ISOILModuleData
         * @property {number|null} [p0] SOILModuleData p0
         * @property {number|null} [p1] SOILModuleData p1
         * @property {number|null} [p2] SOILModuleData p2
         * @property {number|null} [p3] SOILModuleData p3
         * @property {number|null} [p4] SOILModuleData p4
         * @property {number|null} [p5] SOILModuleData p5
         * @property {number|null} [p6] SOILModuleData p6
         * @property {number|null} [p7] SOILModuleData p7
         * @property {number|null} [timestamp] SOILModuleData timestamp
         */
    
        /**
         * Constructs a new SOILModuleData.
         * @exports SOILModuleData
         * @classdesc Represents a SOILModuleData.
         * @implements ISOILModuleData
         * @constructor
         * @param {ISOILModuleData=} [properties] Properties to set
         */
        function SOILModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SOILModuleData p0.
         * @member {number} p0
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p0 = 0;
    
        /**
         * SOILModuleData p1.
         * @member {number} p1
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p1 = 0;
    
        /**
         * SOILModuleData p2.
         * @member {number} p2
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p2 = 0;
    
        /**
         * SOILModuleData p3.
         * @member {number} p3
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p3 = 0;
    
        /**
         * SOILModuleData p4.
         * @member {number} p4
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p4 = 0;
    
        /**
         * SOILModuleData p5.
         * @member {number} p5
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p5 = 0;
    
        /**
         * SOILModuleData p6.
         * @member {number} p6
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p6 = 0;
    
        /**
         * SOILModuleData p7.
         * @member {number} p7
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.p7 = 0;
    
        /**
         * SOILModuleData timestamp.
         * @member {number} timestamp
         * @memberof SOILModuleData
         * @instance
         */
        SOILModuleData.prototype.timestamp = 0;
    
        /**
         * Creates a new SOILModuleData instance using the specified properties.
         * @function create
         * @memberof SOILModuleData
         * @static
         * @param {ISOILModuleData=} [properties] Properties to set
         * @returns {SOILModuleData} SOILModuleData instance
         */
        SOILModuleData.create = function create(properties) {
            return new SOILModuleData(properties);
        };
    
        /**
         * Encodes the specified SOILModuleData message. Does not implicitly {@link SOILModuleData.verify|verify} messages.
         * @function encode
         * @memberof SOILModuleData
         * @static
         * @param {ISOILModuleData} message SOILModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SOILModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && Object.hasOwnProperty.call(message, "p0"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.p0);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.p2);
            if (message.p3 != null && Object.hasOwnProperty.call(message, "p3"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.p3);
            if (message.p4 != null && Object.hasOwnProperty.call(message, "p4"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.p4);
            if (message.p5 != null && Object.hasOwnProperty.call(message, "p5"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.p5);
            if (message.p6 != null && Object.hasOwnProperty.call(message, "p6"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.p6);
            if (message.p7 != null && Object.hasOwnProperty.call(message, "p7"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.p7);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified SOILModuleData message, length delimited. Does not implicitly {@link SOILModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SOILModuleData
         * @static
         * @param {ISOILModuleData} message SOILModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SOILModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SOILModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof SOILModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SOILModuleData} SOILModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SOILModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SOILModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p0 = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                case 3:
                    message.p2 = reader.int32();
                    break;
                case 4:
                    message.p3 = reader.int32();
                    break;
                case 5:
                    message.p4 = reader.int32();
                    break;
                case 6:
                    message.p5 = reader.int32();
                    break;
                case 7:
                    message.p6 = reader.int32();
                    break;
                case 8:
                    message.p7 = reader.int32();
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SOILModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SOILModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SOILModuleData} SOILModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SOILModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SOILModuleData message.
         * @function verify
         * @memberof SOILModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SOILModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0"))
                if (!$util.isInteger(message.p0))
                    return "p0: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            if (message.p2 != null && message.hasOwnProperty("p2"))
                if (!$util.isInteger(message.p2))
                    return "p2: integer expected";
            if (message.p3 != null && message.hasOwnProperty("p3"))
                if (!$util.isInteger(message.p3))
                    return "p3: integer expected";
            if (message.p4 != null && message.hasOwnProperty("p4"))
                if (!$util.isInteger(message.p4))
                    return "p4: integer expected";
            if (message.p5 != null && message.hasOwnProperty("p5"))
                if (!$util.isInteger(message.p5))
                    return "p5: integer expected";
            if (message.p6 != null && message.hasOwnProperty("p6"))
                if (!$util.isInteger(message.p6))
                    return "p6: integer expected";
            if (message.p7 != null && message.hasOwnProperty("p7"))
                if (!$util.isInteger(message.p7))
                    return "p7: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a SOILModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SOILModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SOILModuleData} SOILModuleData
         */
        SOILModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.SOILModuleData)
                return object;
            var message = new $root.SOILModuleData();
            if (object.p0 != null)
                message.p0 = object.p0 | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            if (object.p2 != null)
                message.p2 = object.p2 | 0;
            if (object.p3 != null)
                message.p3 = object.p3 | 0;
            if (object.p4 != null)
                message.p4 = object.p4 | 0;
            if (object.p5 != null)
                message.p5 = object.p5 | 0;
            if (object.p6 != null)
                message.p6 = object.p6 | 0;
            if (object.p7 != null)
                message.p7 = object.p7 | 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a SOILModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SOILModuleData
         * @static
         * @param {SOILModuleData} message SOILModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SOILModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = 0;
                object.p1 = 0;
                object.p2 = 0;
                object.p3 = 0;
                object.p4 = 0;
                object.p5 = 0;
                object.p6 = 0;
                object.p7 = 0;
                object.timestamp = 0;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = message.p0;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = message.p2;
            if (message.p3 != null && message.hasOwnProperty("p3"))
                object.p3 = message.p3;
            if (message.p4 != null && message.hasOwnProperty("p4"))
                object.p4 = message.p4;
            if (message.p5 != null && message.hasOwnProperty("p5"))
                object.p5 = message.p5;
            if (message.p6 != null && message.hasOwnProperty("p6"))
                object.p6 = message.p6;
            if (message.p7 != null && message.hasOwnProperty("p7"))
                object.p7 = message.p7;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this SOILModuleData to JSON.
         * @function toJSON
         * @memberof SOILModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SOILModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SOILModuleData;
    })();
    
    $root.WAModuleData = (function() {
    
        /**
         * Properties of a WAModuleData.
         * @exports IWAModuleData
         * @interface IWAModuleData
         * @property {number|null} [PH] WAModuleData PH
         * @property {number|null} [EC] WAModuleData EC
         * @property {number|null} [temperature] WAModuleData temperature
         * @property {number|null} [timestamp] WAModuleData timestamp
         */
    
        /**
         * Constructs a new WAModuleData.
         * @exports WAModuleData
         * @classdesc Represents a WAModuleData.
         * @implements IWAModuleData
         * @constructor
         * @param {IWAModuleData=} [properties] Properties to set
         */
        function WAModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WAModuleData PH.
         * @member {number} PH
         * @memberof WAModuleData
         * @instance
         */
        WAModuleData.prototype.PH = 0;
    
        /**
         * WAModuleData EC.
         * @member {number} EC
         * @memberof WAModuleData
         * @instance
         */
        WAModuleData.prototype.EC = 0;
    
        /**
         * WAModuleData temperature.
         * @member {number} temperature
         * @memberof WAModuleData
         * @instance
         */
        WAModuleData.prototype.temperature = 0;
    
        /**
         * WAModuleData timestamp.
         * @member {number} timestamp
         * @memberof WAModuleData
         * @instance
         */
        WAModuleData.prototype.timestamp = 0;
    
        /**
         * Creates a new WAModuleData instance using the specified properties.
         * @function create
         * @memberof WAModuleData
         * @static
         * @param {IWAModuleData=} [properties] Properties to set
         * @returns {WAModuleData} WAModuleData instance
         */
        WAModuleData.create = function create(properties) {
            return new WAModuleData(properties);
        };
    
        /**
         * Encodes the specified WAModuleData message. Does not implicitly {@link WAModuleData.verify|verify} messages.
         * @function encode
         * @memberof WAModuleData
         * @static
         * @param {IWAModuleData} message WAModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WAModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PH != null && Object.hasOwnProperty.call(message, "PH"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PH);
            if (message.EC != null && Object.hasOwnProperty.call(message, "EC"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.EC);
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.temperature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified WAModuleData message, length delimited. Does not implicitly {@link WAModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WAModuleData
         * @static
         * @param {IWAModuleData} message WAModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WAModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WAModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof WAModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WAModuleData} WAModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WAModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WAModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.PH = reader.int32();
                    break;
                case 3:
                    message.EC = reader.int32();
                    break;
                case 4:
                    message.temperature = reader.int32();
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a WAModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WAModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WAModuleData} WAModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WAModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WAModuleData message.
         * @function verify
         * @memberof WAModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WAModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PH != null && message.hasOwnProperty("PH"))
                if (!$util.isInteger(message.PH))
                    return "PH: integer expected";
            if (message.EC != null && message.hasOwnProperty("EC"))
                if (!$util.isInteger(message.EC))
                    return "EC: integer expected";
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                if (!$util.isInteger(message.temperature))
                    return "temperature: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a WAModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WAModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WAModuleData} WAModuleData
         */
        WAModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.WAModuleData)
                return object;
            var message = new $root.WAModuleData();
            if (object.PH != null)
                message.PH = object.PH | 0;
            if (object.EC != null)
                message.EC = object.EC | 0;
            if (object.temperature != null)
                message.temperature = object.temperature | 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a WAModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WAModuleData
         * @static
         * @param {WAModuleData} message WAModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WAModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.PH = 0;
                object.EC = 0;
                object.temperature = 0;
                object.timestamp = 0;
            }
            if (message.PH != null && message.hasOwnProperty("PH"))
                object.PH = message.PH;
            if (message.EC != null && message.hasOwnProperty("EC"))
                object.EC = message.EC;
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = message.temperature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this WAModuleData to JSON.
         * @function toJSON
         * @memberof WAModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WAModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WAModuleData;
    })();
    
    /**
     * RelayOutletMode enum.
     * @exports RelayOutletMode
     * @enum {string}
     * @property {number} MANUAL=0 MANUAL value
     * @property {number} ALARM=1 ALARM value
     */
    $root.RelayOutletMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MANUAL"] = 0;
        values[valuesById[1] = "ALARM"] = 1;
        return values;
    })();
    
    $root.CronItem = (function() {
    
        /**
         * Properties of a CronItem.
         * @exports ICronItem
         * @interface ICronItem
         * @property {number|null} [minute] CronItem minute
         * @property {number|null} [hour] CronItem hour
         * @property {number|null} [dayMonth] CronItem dayMonth
         * @property {number|null} [month] CronItem month
         * @property {number|null} [dayWeek] CronItem dayWeek
         */
    
        /**
         * Constructs a new CronItem.
         * @exports CronItem
         * @classdesc Represents a CronItem.
         * @implements ICronItem
         * @constructor
         * @param {ICronItem=} [properties] Properties to set
         */
        function CronItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CronItem minute.
         * @member {number} minute
         * @memberof CronItem
         * @instance
         */
        CronItem.prototype.minute = 0;
    
        /**
         * CronItem hour.
         * @member {number} hour
         * @memberof CronItem
         * @instance
         */
        CronItem.prototype.hour = 0;
    
        /**
         * CronItem dayMonth.
         * @member {number} dayMonth
         * @memberof CronItem
         * @instance
         */
        CronItem.prototype.dayMonth = 0;
    
        /**
         * CronItem month.
         * @member {number} month
         * @memberof CronItem
         * @instance
         */
        CronItem.prototype.month = 0;
    
        /**
         * CronItem dayWeek.
         * @member {number} dayWeek
         * @memberof CronItem
         * @instance
         */
        CronItem.prototype.dayWeek = 0;
    
        /**
         * Creates a new CronItem instance using the specified properties.
         * @function create
         * @memberof CronItem
         * @static
         * @param {ICronItem=} [properties] Properties to set
         * @returns {CronItem} CronItem instance
         */
        CronItem.create = function create(properties) {
            return new CronItem(properties);
        };
    
        /**
         * Encodes the specified CronItem message. Does not implicitly {@link CronItem.verify|verify} messages.
         * @function encode
         * @memberof CronItem
         * @static
         * @param {ICronItem} message CronItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CronItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minute);
            if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hour);
            if (message.dayMonth != null && Object.hasOwnProperty.call(message, "dayMonth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dayMonth);
            if (message.month != null && Object.hasOwnProperty.call(message, "month"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.month);
            if (message.dayWeek != null && Object.hasOwnProperty.call(message, "dayWeek"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.dayWeek);
            return writer;
        };
    
        /**
         * Encodes the specified CronItem message, length delimited. Does not implicitly {@link CronItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CronItem
         * @static
         * @param {ICronItem} message CronItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CronItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CronItem message from the specified reader or buffer.
         * @function decode
         * @memberof CronItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CronItem} CronItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CronItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CronItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minute = reader.int32();
                    break;
                case 2:
                    message.hour = reader.int32();
                    break;
                case 3:
                    message.dayMonth = reader.int32();
                    break;
                case 4:
                    message.month = reader.int32();
                    break;
                case 5:
                    message.dayWeek = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CronItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CronItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CronItem} CronItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CronItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CronItem message.
         * @function verify
         * @memberof CronItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CronItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minute != null && message.hasOwnProperty("minute"))
                if (!$util.isInteger(message.minute))
                    return "minute: integer expected";
            if (message.hour != null && message.hasOwnProperty("hour"))
                if (!$util.isInteger(message.hour))
                    return "hour: integer expected";
            if (message.dayMonth != null && message.hasOwnProperty("dayMonth"))
                if (!$util.isInteger(message.dayMonth))
                    return "dayMonth: integer expected";
            if (message.month != null && message.hasOwnProperty("month"))
                if (!$util.isInteger(message.month))
                    return "month: integer expected";
            if (message.dayWeek != null && message.hasOwnProperty("dayWeek"))
                if (!$util.isInteger(message.dayWeek))
                    return "dayWeek: integer expected";
            return null;
        };
    
        /**
         * Creates a CronItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CronItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CronItem} CronItem
         */
        CronItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CronItem)
                return object;
            var message = new $root.CronItem();
            if (object.minute != null)
                message.minute = object.minute | 0;
            if (object.hour != null)
                message.hour = object.hour | 0;
            if (object.dayMonth != null)
                message.dayMonth = object.dayMonth | 0;
            if (object.month != null)
                message.month = object.month | 0;
            if (object.dayWeek != null)
                message.dayWeek = object.dayWeek | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CronItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CronItem
         * @static
         * @param {CronItem} message CronItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CronItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.minute = 0;
                object.hour = 0;
                object.dayMonth = 0;
                object.month = 0;
                object.dayWeek = 0;
            }
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.hour != null && message.hasOwnProperty("hour"))
                object.hour = message.hour;
            if (message.dayMonth != null && message.hasOwnProperty("dayMonth"))
                object.dayMonth = message.dayMonth;
            if (message.month != null && message.hasOwnProperty("month"))
                object.month = message.month;
            if (message.dayWeek != null && message.hasOwnProperty("dayWeek"))
                object.dayWeek = message.dayWeek;
            return object;
        };
    
        /**
         * Converts this CronItem to JSON.
         * @function toJSON
         * @memberof CronItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CronItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CronItem;
    })();
    
    $root.AlarmConfig = (function() {
    
        /**
         * Properties of an AlarmConfig.
         * @exports IAlarmConfig
         * @interface IAlarmConfig
         * @property {ICronItem|null} [begining] AlarmConfig begining
         * @property {ICronItem|null} [end] AlarmConfig end
         */
    
        /**
         * Constructs a new AlarmConfig.
         * @exports AlarmConfig
         * @classdesc Represents an AlarmConfig.
         * @implements IAlarmConfig
         * @constructor
         * @param {IAlarmConfig=} [properties] Properties to set
         */
        function AlarmConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * AlarmConfig begining.
         * @member {ICronItem|null|undefined} begining
         * @memberof AlarmConfig
         * @instance
         */
        AlarmConfig.prototype.begining = null;
    
        /**
         * AlarmConfig end.
         * @member {ICronItem|null|undefined} end
         * @memberof AlarmConfig
         * @instance
         */
        AlarmConfig.prototype.end = null;
    
        /**
         * Creates a new AlarmConfig instance using the specified properties.
         * @function create
         * @memberof AlarmConfig
         * @static
         * @param {IAlarmConfig=} [properties] Properties to set
         * @returns {AlarmConfig} AlarmConfig instance
         */
        AlarmConfig.create = function create(properties) {
            return new AlarmConfig(properties);
        };
    
        /**
         * Encodes the specified AlarmConfig message. Does not implicitly {@link AlarmConfig.verify|verify} messages.
         * @function encode
         * @memberof AlarmConfig
         * @static
         * @param {IAlarmConfig} message AlarmConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlarmConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.begining != null && Object.hasOwnProperty.call(message, "begining"))
                $root.CronItem.encode(message.begining, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                $root.CronItem.encode(message.end, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified AlarmConfig message, length delimited. Does not implicitly {@link AlarmConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AlarmConfig
         * @static
         * @param {IAlarmConfig} message AlarmConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlarmConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AlarmConfig message from the specified reader or buffer.
         * @function decode
         * @memberof AlarmConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AlarmConfig} AlarmConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlarmConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlarmConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begining = $root.CronItem.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.end = $root.CronItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an AlarmConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AlarmConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AlarmConfig} AlarmConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlarmConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AlarmConfig message.
         * @function verify
         * @memberof AlarmConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlarmConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.begining != null && message.hasOwnProperty("begining")) {
                var error = $root.CronItem.verify(message.begining);
                if (error)
                    return "begining." + error;
            }
            if (message.end != null && message.hasOwnProperty("end")) {
                var error = $root.CronItem.verify(message.end);
                if (error)
                    return "end." + error;
            }
            return null;
        };
    
        /**
         * Creates an AlarmConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AlarmConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AlarmConfig} AlarmConfig
         */
        AlarmConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.AlarmConfig)
                return object;
            var message = new $root.AlarmConfig();
            if (object.begining != null) {
                if (typeof object.begining !== "object")
                    throw TypeError(".AlarmConfig.begining: object expected");
                message.begining = $root.CronItem.fromObject(object.begining);
            }
            if (object.end != null) {
                if (typeof object.end !== "object")
                    throw TypeError(".AlarmConfig.end: object expected");
                message.end = $root.CronItem.fromObject(object.end);
            }
            return message;
        };
    
        /**
         * Creates a plain object from an AlarmConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AlarmConfig
         * @static
         * @param {AlarmConfig} message AlarmConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlarmConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.begining = null;
                object.end = null;
            }
            if (message.begining != null && message.hasOwnProperty("begining"))
                object.begining = $root.CronItem.toObject(message.begining, options);
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = $root.CronItem.toObject(message.end, options);
            return object;
        };
    
        /**
         * Converts this AlarmConfig to JSON.
         * @function toJSON
         * @memberof AlarmConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlarmConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AlarmConfig;
    })();
    
    $root.ManualConfig = (function() {
    
        /**
         * Properties of a ManualConfig.
         * @exports IManualConfig
         * @interface IManualConfig
         * @property {boolean|null} [state] ManualConfig state
         * @property {number|null} [duration] ManualConfig duration
         */
    
        /**
         * Constructs a new ManualConfig.
         * @exports ManualConfig
         * @classdesc Represents a ManualConfig.
         * @implements IManualConfig
         * @constructor
         * @param {IManualConfig=} [properties] Properties to set
         */
        function ManualConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ManualConfig state.
         * @member {boolean} state
         * @memberof ManualConfig
         * @instance
         */
        ManualConfig.prototype.state = false;
    
        /**
         * ManualConfig duration.
         * @member {number} duration
         * @memberof ManualConfig
         * @instance
         */
        ManualConfig.prototype.duration = 0;
    
        /**
         * Creates a new ManualConfig instance using the specified properties.
         * @function create
         * @memberof ManualConfig
         * @static
         * @param {IManualConfig=} [properties] Properties to set
         * @returns {ManualConfig} ManualConfig instance
         */
        ManualConfig.create = function create(properties) {
            return new ManualConfig(properties);
        };
    
        /**
         * Encodes the specified ManualConfig message. Does not implicitly {@link ManualConfig.verify|verify} messages.
         * @function encode
         * @memberof ManualConfig
         * @static
         * @param {IManualConfig} message ManualConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ManualConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.state);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.duration);
            return writer;
        };
    
        /**
         * Encodes the specified ManualConfig message, length delimited. Does not implicitly {@link ManualConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ManualConfig
         * @static
         * @param {IManualConfig} message ManualConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ManualConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ManualConfig message from the specified reader or buffer.
         * @function decode
         * @memberof ManualConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ManualConfig} ManualConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManualConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ManualConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.bool();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ManualConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ManualConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ManualConfig} ManualConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ManualConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ManualConfig message.
         * @function verify
         * @memberof ManualConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ManualConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            return null;
        };
    
        /**
         * Creates a ManualConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ManualConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ManualConfig} ManualConfig
         */
        ManualConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.ManualConfig)
                return object;
            var message = new $root.ManualConfig();
            if (object.state != null)
                message.state = Boolean(object.state);
            if (object.duration != null)
                message.duration = object.duration | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ManualConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ManualConfig
         * @static
         * @param {ManualConfig} message ManualConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ManualConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.state = false;
                object.duration = 0;
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            return object;
        };
    
        /**
         * Converts this ManualConfig to JSON.
         * @function toJSON
         * @memberof ManualConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ManualConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ManualConfig;
    })();
    
    $root.RelayOutletData = (function() {
    
        /**
         * Properties of a RelayOutletData.
         * @exports IRelayOutletData
         * @interface IRelayOutletData
         * @property {boolean|null} [state] RelayOutletData state
         */
    
        /**
         * Constructs a new RelayOutletData.
         * @exports RelayOutletData
         * @classdesc Represents a RelayOutletData.
         * @implements IRelayOutletData
         * @constructor
         * @param {IRelayOutletData=} [properties] Properties to set
         */
        function RelayOutletData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RelayOutletData state.
         * @member {boolean} state
         * @memberof RelayOutletData
         * @instance
         */
        RelayOutletData.prototype.state = false;
    
        /**
         * Creates a new RelayOutletData instance using the specified properties.
         * @function create
         * @memberof RelayOutletData
         * @static
         * @param {IRelayOutletData=} [properties] Properties to set
         * @returns {RelayOutletData} RelayOutletData instance
         */
        RelayOutletData.create = function create(properties) {
            return new RelayOutletData(properties);
        };
    
        /**
         * Encodes the specified RelayOutletData message. Does not implicitly {@link RelayOutletData.verify|verify} messages.
         * @function encode
         * @memberof RelayOutletData
         * @static
         * @param {IRelayOutletData} message RelayOutletData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayOutletData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.state);
            return writer;
        };
    
        /**
         * Encodes the specified RelayOutletData message, length delimited. Does not implicitly {@link RelayOutletData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RelayOutletData
         * @static
         * @param {IRelayOutletData} message RelayOutletData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayOutletData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RelayOutletData message from the specified reader or buffer.
         * @function decode
         * @memberof RelayOutletData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RelayOutletData} RelayOutletData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayOutletData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelayOutletData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RelayOutletData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RelayOutletData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RelayOutletData} RelayOutletData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayOutletData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RelayOutletData message.
         * @function verify
         * @memberof RelayOutletData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelayOutletData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };
    
        /**
         * Creates a RelayOutletData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RelayOutletData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RelayOutletData} RelayOutletData
         */
        RelayOutletData.fromObject = function fromObject(object) {
            if (object instanceof $root.RelayOutletData)
                return object;
            var message = new $root.RelayOutletData();
            if (object.state != null)
                message.state = Boolean(object.state);
            return message;
        };
    
        /**
         * Creates a plain object from a RelayOutletData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RelayOutletData
         * @static
         * @param {RelayOutletData} message RelayOutletData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelayOutletData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.state = false;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };
    
        /**
         * Converts this RelayOutletData to JSON.
         * @function toJSON
         * @memberof RelayOutletData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelayOutletData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RelayOutletData;
    })();
    
    $root.RelayOutletConfig = (function() {
    
        /**
         * Properties of a RelayOutletConfig.
         * @exports IRelayOutletConfig
         * @interface IRelayOutletConfig
         * @property {RelayOutletMode|null} [mode] RelayOutletConfig mode
         * @property {IAlarmConfig|null} [alarm] RelayOutletConfig alarm
         * @property {IManualConfig|null} [manual] RelayOutletConfig manual
         */
    
        /**
         * Constructs a new RelayOutletConfig.
         * @exports RelayOutletConfig
         * @classdesc Represents a RelayOutletConfig.
         * @implements IRelayOutletConfig
         * @constructor
         * @param {IRelayOutletConfig=} [properties] Properties to set
         */
        function RelayOutletConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RelayOutletConfig mode.
         * @member {RelayOutletMode} mode
         * @memberof RelayOutletConfig
         * @instance
         */
        RelayOutletConfig.prototype.mode = 0;
    
        /**
         * RelayOutletConfig alarm.
         * @member {IAlarmConfig|null|undefined} alarm
         * @memberof RelayOutletConfig
         * @instance
         */
        RelayOutletConfig.prototype.alarm = null;
    
        /**
         * RelayOutletConfig manual.
         * @member {IManualConfig|null|undefined} manual
         * @memberof RelayOutletConfig
         * @instance
         */
        RelayOutletConfig.prototype.manual = null;
    
        /**
         * Creates a new RelayOutletConfig instance using the specified properties.
         * @function create
         * @memberof RelayOutletConfig
         * @static
         * @param {IRelayOutletConfig=} [properties] Properties to set
         * @returns {RelayOutletConfig} RelayOutletConfig instance
         */
        RelayOutletConfig.create = function create(properties) {
            return new RelayOutletConfig(properties);
        };
    
        /**
         * Encodes the specified RelayOutletConfig message. Does not implicitly {@link RelayOutletConfig.verify|verify} messages.
         * @function encode
         * @memberof RelayOutletConfig
         * @static
         * @param {IRelayOutletConfig} message RelayOutletConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayOutletConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            if (message.alarm != null && Object.hasOwnProperty.call(message, "alarm"))
                $root.AlarmConfig.encode(message.alarm, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.manual != null && Object.hasOwnProperty.call(message, "manual"))
                $root.ManualConfig.encode(message.manual, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified RelayOutletConfig message, length delimited. Does not implicitly {@link RelayOutletConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RelayOutletConfig
         * @static
         * @param {IRelayOutletConfig} message RelayOutletConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayOutletConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RelayOutletConfig message from the specified reader or buffer.
         * @function decode
         * @memberof RelayOutletConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RelayOutletConfig} RelayOutletConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayOutletConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelayOutletConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.alarm = $root.AlarmConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.manual = $root.ManualConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RelayOutletConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RelayOutletConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RelayOutletConfig} RelayOutletConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayOutletConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RelayOutletConfig message.
         * @function verify
         * @memberof RelayOutletConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelayOutletConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.alarm != null && message.hasOwnProperty("alarm")) {
                var error = $root.AlarmConfig.verify(message.alarm);
                if (error)
                    return "alarm." + error;
            }
            if (message.manual != null && message.hasOwnProperty("manual")) {
                var error = $root.ManualConfig.verify(message.manual);
                if (error)
                    return "manual." + error;
            }
            return null;
        };
    
        /**
         * Creates a RelayOutletConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RelayOutletConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RelayOutletConfig} RelayOutletConfig
         */
        RelayOutletConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.RelayOutletConfig)
                return object;
            var message = new $root.RelayOutletConfig();
            switch (object.mode) {
            case "MANUAL":
            case 0:
                message.mode = 0;
                break;
            case "ALARM":
            case 1:
                message.mode = 1;
                break;
            }
            if (object.alarm != null) {
                if (typeof object.alarm !== "object")
                    throw TypeError(".RelayOutletConfig.alarm: object expected");
                message.alarm = $root.AlarmConfig.fromObject(object.alarm);
            }
            if (object.manual != null) {
                if (typeof object.manual !== "object")
                    throw TypeError(".RelayOutletConfig.manual: object expected");
                message.manual = $root.ManualConfig.fromObject(object.manual);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a RelayOutletConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RelayOutletConfig
         * @static
         * @param {RelayOutletConfig} message RelayOutletConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelayOutletConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = options.enums === String ? "MANUAL" : 0;
                object.alarm = null;
                object.manual = null;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.RelayOutletMode[message.mode] : message.mode;
            if (message.alarm != null && message.hasOwnProperty("alarm"))
                object.alarm = $root.AlarmConfig.toObject(message.alarm, options);
            if (message.manual != null && message.hasOwnProperty("manual"))
                object.manual = $root.ManualConfig.toObject(message.manual, options);
            return object;
        };
    
        /**
         * Converts this RelayOutletConfig to JSON.
         * @function toJSON
         * @memberof RelayOutletConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelayOutletConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RelayOutletConfig;
    })();
    
    $root.RelayModuleData = (function() {
    
        /**
         * Properties of a RelayModuleData.
         * @exports IRelayModuleData
         * @interface IRelayModuleData
         * @property {IRelayOutletData|null} [p0] RelayModuleData p0
         * @property {IRelayOutletData|null} [p1] RelayModuleData p1
         * @property {IRelayOutletData|null} [p2] RelayModuleData p2
         * @property {IRelayOutletData|null} [p3] RelayModuleData p3
         * @property {IRelayOutletData|null} [p4] RelayModuleData p4
         * @property {IRelayOutletData|null} [p5] RelayModuleData p5
         * @property {IRelayOutletData|null} [p6] RelayModuleData p6
         * @property {IRelayOutletData|null} [p7] RelayModuleData p7
         * @property {number|null} [timestamp] RelayModuleData timestamp
         */
    
        /**
         * Constructs a new RelayModuleData.
         * @exports RelayModuleData
         * @classdesc Represents a RelayModuleData.
         * @implements IRelayModuleData
         * @constructor
         * @param {IRelayModuleData=} [properties] Properties to set
         */
        function RelayModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RelayModuleData p0.
         * @member {IRelayOutletData|null|undefined} p0
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p0 = null;
    
        /**
         * RelayModuleData p1.
         * @member {IRelayOutletData|null|undefined} p1
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p1 = null;
    
        /**
         * RelayModuleData p2.
         * @member {IRelayOutletData|null|undefined} p2
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p2 = null;
    
        /**
         * RelayModuleData p3.
         * @member {IRelayOutletData|null|undefined} p3
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p3 = null;
    
        /**
         * RelayModuleData p4.
         * @member {IRelayOutletData|null|undefined} p4
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p4 = null;
    
        /**
         * RelayModuleData p5.
         * @member {IRelayOutletData|null|undefined} p5
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p5 = null;
    
        /**
         * RelayModuleData p6.
         * @member {IRelayOutletData|null|undefined} p6
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p6 = null;
    
        /**
         * RelayModuleData p7.
         * @member {IRelayOutletData|null|undefined} p7
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.p7 = null;
    
        /**
         * RelayModuleData timestamp.
         * @member {number} timestamp
         * @memberof RelayModuleData
         * @instance
         */
        RelayModuleData.prototype.timestamp = 0;
    
        /**
         * Creates a new RelayModuleData instance using the specified properties.
         * @function create
         * @memberof RelayModuleData
         * @static
         * @param {IRelayModuleData=} [properties] Properties to set
         * @returns {RelayModuleData} RelayModuleData instance
         */
        RelayModuleData.create = function create(properties) {
            return new RelayModuleData(properties);
        };
    
        /**
         * Encodes the specified RelayModuleData message. Does not implicitly {@link RelayModuleData.verify|verify} messages.
         * @function encode
         * @memberof RelayModuleData
         * @static
         * @param {IRelayModuleData} message RelayModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && Object.hasOwnProperty.call(message, "p0"))
                $root.RelayOutletData.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                $root.RelayOutletData.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                $root.RelayOutletData.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.p3 != null && Object.hasOwnProperty.call(message, "p3"))
                $root.RelayOutletData.encode(message.p3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.p4 != null && Object.hasOwnProperty.call(message, "p4"))
                $root.RelayOutletData.encode(message.p4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.p5 != null && Object.hasOwnProperty.call(message, "p5"))
                $root.RelayOutletData.encode(message.p5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.p6 != null && Object.hasOwnProperty.call(message, "p6"))
                $root.RelayOutletData.encode(message.p6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.p7 != null && Object.hasOwnProperty.call(message, "p7"))
                $root.RelayOutletData.encode(message.p7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified RelayModuleData message, length delimited. Does not implicitly {@link RelayModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RelayModuleData
         * @static
         * @param {IRelayModuleData} message RelayModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RelayModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof RelayModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RelayModuleData} RelayModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelayModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p0 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.p1 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.p2 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.p3 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.p4 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.p5 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.p6 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.p7 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RelayModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RelayModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RelayModuleData} RelayModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RelayModuleData message.
         * @function verify
         * @memberof RelayModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelayModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.RelayOutletData.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                var error = $root.RelayOutletData.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            if (message.p2 != null && message.hasOwnProperty("p2")) {
                var error = $root.RelayOutletData.verify(message.p2);
                if (error)
                    return "p2." + error;
            }
            if (message.p3 != null && message.hasOwnProperty("p3")) {
                var error = $root.RelayOutletData.verify(message.p3);
                if (error)
                    return "p3." + error;
            }
            if (message.p4 != null && message.hasOwnProperty("p4")) {
                var error = $root.RelayOutletData.verify(message.p4);
                if (error)
                    return "p4." + error;
            }
            if (message.p5 != null && message.hasOwnProperty("p5")) {
                var error = $root.RelayOutletData.verify(message.p5);
                if (error)
                    return "p5." + error;
            }
            if (message.p6 != null && message.hasOwnProperty("p6")) {
                var error = $root.RelayOutletData.verify(message.p6);
                if (error)
                    return "p6." + error;
            }
            if (message.p7 != null && message.hasOwnProperty("p7")) {
                var error = $root.RelayOutletData.verify(message.p7);
                if (error)
                    return "p7." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a RelayModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RelayModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RelayModuleData} RelayModuleData
         */
        RelayModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.RelayModuleData)
                return object;
            var message = new $root.RelayModuleData();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".RelayModuleData.p0: object expected");
                message.p0 = $root.RelayOutletData.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".RelayModuleData.p1: object expected");
                message.p1 = $root.RelayOutletData.fromObject(object.p1);
            }
            if (object.p2 != null) {
                if (typeof object.p2 !== "object")
                    throw TypeError(".RelayModuleData.p2: object expected");
                message.p2 = $root.RelayOutletData.fromObject(object.p2);
            }
            if (object.p3 != null) {
                if (typeof object.p3 !== "object")
                    throw TypeError(".RelayModuleData.p3: object expected");
                message.p3 = $root.RelayOutletData.fromObject(object.p3);
            }
            if (object.p4 != null) {
                if (typeof object.p4 !== "object")
                    throw TypeError(".RelayModuleData.p4: object expected");
                message.p4 = $root.RelayOutletData.fromObject(object.p4);
            }
            if (object.p5 != null) {
                if (typeof object.p5 !== "object")
                    throw TypeError(".RelayModuleData.p5: object expected");
                message.p5 = $root.RelayOutletData.fromObject(object.p5);
            }
            if (object.p6 != null) {
                if (typeof object.p6 !== "object")
                    throw TypeError(".RelayModuleData.p6: object expected");
                message.p6 = $root.RelayOutletData.fromObject(object.p6);
            }
            if (object.p7 != null) {
                if (typeof object.p7 !== "object")
                    throw TypeError(".RelayModuleData.p7: object expected");
                message.p7 = $root.RelayOutletData.fromObject(object.p7);
            }
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a RelayModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RelayModuleData
         * @static
         * @param {RelayModuleData} message RelayModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelayModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
                object.p2 = null;
                object.p3 = null;
                object.p4 = null;
                object.p5 = null;
                object.p6 = null;
                object.p7 = null;
                object.timestamp = 0;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.RelayOutletData.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.RelayOutletData.toObject(message.p1, options);
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = $root.RelayOutletData.toObject(message.p2, options);
            if (message.p3 != null && message.hasOwnProperty("p3"))
                object.p3 = $root.RelayOutletData.toObject(message.p3, options);
            if (message.p4 != null && message.hasOwnProperty("p4"))
                object.p4 = $root.RelayOutletData.toObject(message.p4, options);
            if (message.p5 != null && message.hasOwnProperty("p5"))
                object.p5 = $root.RelayOutletData.toObject(message.p5, options);
            if (message.p6 != null && message.hasOwnProperty("p6"))
                object.p6 = $root.RelayOutletData.toObject(message.p6, options);
            if (message.p7 != null && message.hasOwnProperty("p7"))
                object.p7 = $root.RelayOutletData.toObject(message.p7, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this RelayModuleData to JSON.
         * @function toJSON
         * @memberof RelayModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelayModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RelayModuleData;
    })();
    
    $root.RelayModuleConfig = (function() {
    
        /**
         * Properties of a RelayModuleConfig.
         * @exports IRelayModuleConfig
         * @interface IRelayModuleConfig
         * @property {IRelayOutletConfig|null} [p0] RelayModuleConfig p0
         * @property {IRelayOutletConfig|null} [p1] RelayModuleConfig p1
         * @property {IRelayOutletConfig|null} [p2] RelayModuleConfig p2
         * @property {IRelayOutletConfig|null} [p3] RelayModuleConfig p3
         * @property {IRelayOutletConfig|null} [p4] RelayModuleConfig p4
         * @property {IRelayOutletConfig|null} [p5] RelayModuleConfig p5
         * @property {IRelayOutletConfig|null} [p6] RelayModuleConfig p6
         * @property {IRelayOutletConfig|null} [p7] RelayModuleConfig p7
         * @property {number|null} [timestamp] RelayModuleConfig timestamp
         */
    
        /**
         * Constructs a new RelayModuleConfig.
         * @exports RelayModuleConfig
         * @classdesc Represents a RelayModuleConfig.
         * @implements IRelayModuleConfig
         * @constructor
         * @param {IRelayModuleConfig=} [properties] Properties to set
         */
        function RelayModuleConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RelayModuleConfig p0.
         * @member {IRelayOutletConfig|null|undefined} p0
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p0 = null;
    
        /**
         * RelayModuleConfig p1.
         * @member {IRelayOutletConfig|null|undefined} p1
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p1 = null;
    
        /**
         * RelayModuleConfig p2.
         * @member {IRelayOutletConfig|null|undefined} p2
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p2 = null;
    
        /**
         * RelayModuleConfig p3.
         * @member {IRelayOutletConfig|null|undefined} p3
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p3 = null;
    
        /**
         * RelayModuleConfig p4.
         * @member {IRelayOutletConfig|null|undefined} p4
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p4 = null;
    
        /**
         * RelayModuleConfig p5.
         * @member {IRelayOutletConfig|null|undefined} p5
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p5 = null;
    
        /**
         * RelayModuleConfig p6.
         * @member {IRelayOutletConfig|null|undefined} p6
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p6 = null;
    
        /**
         * RelayModuleConfig p7.
         * @member {IRelayOutletConfig|null|undefined} p7
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.p7 = null;
    
        /**
         * RelayModuleConfig timestamp.
         * @member {number} timestamp
         * @memberof RelayModuleConfig
         * @instance
         */
        RelayModuleConfig.prototype.timestamp = 0;
    
        /**
         * Creates a new RelayModuleConfig instance using the specified properties.
         * @function create
         * @memberof RelayModuleConfig
         * @static
         * @param {IRelayModuleConfig=} [properties] Properties to set
         * @returns {RelayModuleConfig} RelayModuleConfig instance
         */
        RelayModuleConfig.create = function create(properties) {
            return new RelayModuleConfig(properties);
        };
    
        /**
         * Encodes the specified RelayModuleConfig message. Does not implicitly {@link RelayModuleConfig.verify|verify} messages.
         * @function encode
         * @memberof RelayModuleConfig
         * @static
         * @param {IRelayModuleConfig} message RelayModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayModuleConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && Object.hasOwnProperty.call(message, "p0"))
                $root.RelayOutletConfig.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                $root.RelayOutletConfig.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                $root.RelayOutletConfig.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.p3 != null && Object.hasOwnProperty.call(message, "p3"))
                $root.RelayOutletConfig.encode(message.p3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.p4 != null && Object.hasOwnProperty.call(message, "p4"))
                $root.RelayOutletConfig.encode(message.p4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.p5 != null && Object.hasOwnProperty.call(message, "p5"))
                $root.RelayOutletConfig.encode(message.p5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.p6 != null && Object.hasOwnProperty.call(message, "p6"))
                $root.RelayOutletConfig.encode(message.p6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.p7 != null && Object.hasOwnProperty.call(message, "p7"))
                $root.RelayOutletConfig.encode(message.p7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified RelayModuleConfig message, length delimited. Does not implicitly {@link RelayModuleConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RelayModuleConfig
         * @static
         * @param {IRelayModuleConfig} message RelayModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayModuleConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RelayModuleConfig message from the specified reader or buffer.
         * @function decode
         * @memberof RelayModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RelayModuleConfig} RelayModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayModuleConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelayModuleConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p0 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.p1 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.p2 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.p3 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.p4 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.p5 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.p6 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.p7 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RelayModuleConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RelayModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RelayModuleConfig} RelayModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayModuleConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RelayModuleConfig message.
         * @function verify
         * @memberof RelayModuleConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelayModuleConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.RelayOutletConfig.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                var error = $root.RelayOutletConfig.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            if (message.p2 != null && message.hasOwnProperty("p2")) {
                var error = $root.RelayOutletConfig.verify(message.p2);
                if (error)
                    return "p2." + error;
            }
            if (message.p3 != null && message.hasOwnProperty("p3")) {
                var error = $root.RelayOutletConfig.verify(message.p3);
                if (error)
                    return "p3." + error;
            }
            if (message.p4 != null && message.hasOwnProperty("p4")) {
                var error = $root.RelayOutletConfig.verify(message.p4);
                if (error)
                    return "p4." + error;
            }
            if (message.p5 != null && message.hasOwnProperty("p5")) {
                var error = $root.RelayOutletConfig.verify(message.p5);
                if (error)
                    return "p5." + error;
            }
            if (message.p6 != null && message.hasOwnProperty("p6")) {
                var error = $root.RelayOutletConfig.verify(message.p6);
                if (error)
                    return "p6." + error;
            }
            if (message.p7 != null && message.hasOwnProperty("p7")) {
                var error = $root.RelayOutletConfig.verify(message.p7);
                if (error)
                    return "p7." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a RelayModuleConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RelayModuleConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RelayModuleConfig} RelayModuleConfig
         */
        RelayModuleConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.RelayModuleConfig)
                return object;
            var message = new $root.RelayModuleConfig();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".RelayModuleConfig.p0: object expected");
                message.p0 = $root.RelayOutletConfig.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".RelayModuleConfig.p1: object expected");
                message.p1 = $root.RelayOutletConfig.fromObject(object.p1);
            }
            if (object.p2 != null) {
                if (typeof object.p2 !== "object")
                    throw TypeError(".RelayModuleConfig.p2: object expected");
                message.p2 = $root.RelayOutletConfig.fromObject(object.p2);
            }
            if (object.p3 != null) {
                if (typeof object.p3 !== "object")
                    throw TypeError(".RelayModuleConfig.p3: object expected");
                message.p3 = $root.RelayOutletConfig.fromObject(object.p3);
            }
            if (object.p4 != null) {
                if (typeof object.p4 !== "object")
                    throw TypeError(".RelayModuleConfig.p4: object expected");
                message.p4 = $root.RelayOutletConfig.fromObject(object.p4);
            }
            if (object.p5 != null) {
                if (typeof object.p5 !== "object")
                    throw TypeError(".RelayModuleConfig.p5: object expected");
                message.p5 = $root.RelayOutletConfig.fromObject(object.p5);
            }
            if (object.p6 != null) {
                if (typeof object.p6 !== "object")
                    throw TypeError(".RelayModuleConfig.p6: object expected");
                message.p6 = $root.RelayOutletConfig.fromObject(object.p6);
            }
            if (object.p7 != null) {
                if (typeof object.p7 !== "object")
                    throw TypeError(".RelayModuleConfig.p7: object expected");
                message.p7 = $root.RelayOutletConfig.fromObject(object.p7);
            }
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a RelayModuleConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RelayModuleConfig
         * @static
         * @param {RelayModuleConfig} message RelayModuleConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelayModuleConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
                object.p2 = null;
                object.p3 = null;
                object.p4 = null;
                object.p5 = null;
                object.p6 = null;
                object.p7 = null;
                object.timestamp = 0;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.RelayOutletConfig.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.RelayOutletConfig.toObject(message.p1, options);
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = $root.RelayOutletConfig.toObject(message.p2, options);
            if (message.p3 != null && message.hasOwnProperty("p3"))
                object.p3 = $root.RelayOutletConfig.toObject(message.p3, options);
            if (message.p4 != null && message.hasOwnProperty("p4"))
                object.p4 = $root.RelayOutletConfig.toObject(message.p4, options);
            if (message.p5 != null && message.hasOwnProperty("p5"))
                object.p5 = $root.RelayOutletConfig.toObject(message.p5, options);
            if (message.p6 != null && message.hasOwnProperty("p6"))
                object.p6 = $root.RelayOutletConfig.toObject(message.p6, options);
            if (message.p7 != null && message.hasOwnProperty("p7"))
                object.p7 = $root.RelayOutletConfig.toObject(message.p7, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this RelayModuleConfig to JSON.
         * @function toJSON
         * @memberof RelayModuleConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelayModuleConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RelayModuleConfig;
    })();
    
    $root.WCModuleData = (function() {
    
        /**
         * Properties of a WCModuleData.
         * @exports IWCModuleData
         * @interface IWCModuleData
         * @property {IRelayOutletData|null} [p0] WCModuleData p0
         * @property {IRelayOutletData|null} [p1] WCModuleData p1
         * @property {IRelayOutletData|null} [p2] WCModuleData p2
         * @property {IRelayOutletData|null} [drain] WCModuleData drain
         * @property {IRelayOutletData|null} [pump0] WCModuleData pump0
         * @property {IRelayOutletData|null} [pump1] WCModuleData pump1
         * @property {IRelayOutletData|null} [pump2] WCModuleData pump2
         * @property {IRelayOutletData|null} [pump3] WCModuleData pump3
         * @property {number|null} [timestamp] WCModuleData timestamp
         */
    
        /**
         * Constructs a new WCModuleData.
         * @exports WCModuleData
         * @classdesc Represents a WCModuleData.
         * @implements IWCModuleData
         * @constructor
         * @param {IWCModuleData=} [properties] Properties to set
         */
        function WCModuleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WCModuleData p0.
         * @member {IRelayOutletData|null|undefined} p0
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.p0 = null;
    
        /**
         * WCModuleData p1.
         * @member {IRelayOutletData|null|undefined} p1
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.p1 = null;
    
        /**
         * WCModuleData p2.
         * @member {IRelayOutletData|null|undefined} p2
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.p2 = null;
    
        /**
         * WCModuleData drain.
         * @member {IRelayOutletData|null|undefined} drain
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.drain = null;
    
        /**
         * WCModuleData pump0.
         * @member {IRelayOutletData|null|undefined} pump0
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.pump0 = null;
    
        /**
         * WCModuleData pump1.
         * @member {IRelayOutletData|null|undefined} pump1
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.pump1 = null;
    
        /**
         * WCModuleData pump2.
         * @member {IRelayOutletData|null|undefined} pump2
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.pump2 = null;
    
        /**
         * WCModuleData pump3.
         * @member {IRelayOutletData|null|undefined} pump3
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.pump3 = null;
    
        /**
         * WCModuleData timestamp.
         * @member {number} timestamp
         * @memberof WCModuleData
         * @instance
         */
        WCModuleData.prototype.timestamp = 0;
    
        /**
         * Creates a new WCModuleData instance using the specified properties.
         * @function create
         * @memberof WCModuleData
         * @static
         * @param {IWCModuleData=} [properties] Properties to set
         * @returns {WCModuleData} WCModuleData instance
         */
        WCModuleData.create = function create(properties) {
            return new WCModuleData(properties);
        };
    
        /**
         * Encodes the specified WCModuleData message. Does not implicitly {@link WCModuleData.verify|verify} messages.
         * @function encode
         * @memberof WCModuleData
         * @static
         * @param {IWCModuleData} message WCModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WCModuleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && Object.hasOwnProperty.call(message, "p0"))
                $root.RelayOutletData.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                $root.RelayOutletData.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                $root.RelayOutletData.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.drain != null && Object.hasOwnProperty.call(message, "drain"))
                $root.RelayOutletData.encode(message.drain, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pump0 != null && Object.hasOwnProperty.call(message, "pump0"))
                $root.RelayOutletData.encode(message.pump0, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pump1 != null && Object.hasOwnProperty.call(message, "pump1"))
                $root.RelayOutletData.encode(message.pump1, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pump2 != null && Object.hasOwnProperty.call(message, "pump2"))
                $root.RelayOutletData.encode(message.pump2, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.pump3 != null && Object.hasOwnProperty.call(message, "pump3"))
                $root.RelayOutletData.encode(message.pump3, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified WCModuleData message, length delimited. Does not implicitly {@link WCModuleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WCModuleData
         * @static
         * @param {IWCModuleData} message WCModuleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WCModuleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WCModuleData message from the specified reader or buffer.
         * @function decode
         * @memberof WCModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WCModuleData} WCModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WCModuleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WCModuleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p0 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.p1 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.p2 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.drain = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.pump0 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.pump1 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pump2 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.pump3 = $root.RelayOutletData.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.timestamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a WCModuleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WCModuleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WCModuleData} WCModuleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WCModuleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WCModuleData message.
         * @function verify
         * @memberof WCModuleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WCModuleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.RelayOutletData.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                var error = $root.RelayOutletData.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            if (message.p2 != null && message.hasOwnProperty("p2")) {
                var error = $root.RelayOutletData.verify(message.p2);
                if (error)
                    return "p2." + error;
            }
            if (message.drain != null && message.hasOwnProperty("drain")) {
                var error = $root.RelayOutletData.verify(message.drain);
                if (error)
                    return "drain." + error;
            }
            if (message.pump0 != null && message.hasOwnProperty("pump0")) {
                var error = $root.RelayOutletData.verify(message.pump0);
                if (error)
                    return "pump0." + error;
            }
            if (message.pump1 != null && message.hasOwnProperty("pump1")) {
                var error = $root.RelayOutletData.verify(message.pump1);
                if (error)
                    return "pump1." + error;
            }
            if (message.pump2 != null && message.hasOwnProperty("pump2")) {
                var error = $root.RelayOutletData.verify(message.pump2);
                if (error)
                    return "pump2." + error;
            }
            if (message.pump3 != null && message.hasOwnProperty("pump3")) {
                var error = $root.RelayOutletData.verify(message.pump3);
                if (error)
                    return "pump3." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a WCModuleData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WCModuleData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WCModuleData} WCModuleData
         */
        WCModuleData.fromObject = function fromObject(object) {
            if (object instanceof $root.WCModuleData)
                return object;
            var message = new $root.WCModuleData();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".WCModuleData.p0: object expected");
                message.p0 = $root.RelayOutletData.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".WCModuleData.p1: object expected");
                message.p1 = $root.RelayOutletData.fromObject(object.p1);
            }
            if (object.p2 != null) {
                if (typeof object.p2 !== "object")
                    throw TypeError(".WCModuleData.p2: object expected");
                message.p2 = $root.RelayOutletData.fromObject(object.p2);
            }
            if (object.drain != null) {
                if (typeof object.drain !== "object")
                    throw TypeError(".WCModuleData.drain: object expected");
                message.drain = $root.RelayOutletData.fromObject(object.drain);
            }
            if (object.pump0 != null) {
                if (typeof object.pump0 !== "object")
                    throw TypeError(".WCModuleData.pump0: object expected");
                message.pump0 = $root.RelayOutletData.fromObject(object.pump0);
            }
            if (object.pump1 != null) {
                if (typeof object.pump1 !== "object")
                    throw TypeError(".WCModuleData.pump1: object expected");
                message.pump1 = $root.RelayOutletData.fromObject(object.pump1);
            }
            if (object.pump2 != null) {
                if (typeof object.pump2 !== "object")
                    throw TypeError(".WCModuleData.pump2: object expected");
                message.pump2 = $root.RelayOutletData.fromObject(object.pump2);
            }
            if (object.pump3 != null) {
                if (typeof object.pump3 !== "object")
                    throw TypeError(".WCModuleData.pump3: object expected");
                message.pump3 = $root.RelayOutletData.fromObject(object.pump3);
            }
            if (object.timestamp != null)
                message.timestamp = object.timestamp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a WCModuleData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WCModuleData
         * @static
         * @param {WCModuleData} message WCModuleData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WCModuleData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
                object.p2 = null;
                object.drain = null;
                object.pump0 = null;
                object.pump1 = null;
                object.pump2 = null;
                object.pump3 = null;
                object.timestamp = 0;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.RelayOutletData.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.RelayOutletData.toObject(message.p1, options);
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = $root.RelayOutletData.toObject(message.p2, options);
            if (message.drain != null && message.hasOwnProperty("drain"))
                object.drain = $root.RelayOutletData.toObject(message.drain, options);
            if (message.pump0 != null && message.hasOwnProperty("pump0"))
                object.pump0 = $root.RelayOutletData.toObject(message.pump0, options);
            if (message.pump1 != null && message.hasOwnProperty("pump1"))
                object.pump1 = $root.RelayOutletData.toObject(message.pump1, options);
            if (message.pump2 != null && message.hasOwnProperty("pump2"))
                object.pump2 = $root.RelayOutletData.toObject(message.pump2, options);
            if (message.pump3 != null && message.hasOwnProperty("pump3"))
                object.pump3 = $root.RelayOutletData.toObject(message.pump3, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this WCModuleData to JSON.
         * @function toJSON
         * @memberof WCModuleData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WCModuleData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WCModuleData;
    })();
    
    $root.WCModuleConfig = (function() {
    
        /**
         * Properties of a WCModuleConfig.
         * @exports IWCModuleConfig
         * @interface IWCModuleConfig
         * @property {IRelayOutletConfig|null} [p0] WCModuleConfig p0
         * @property {IRelayOutletConfig|null} [p1] WCModuleConfig p1
         * @property {IRelayOutletConfig|null} [p2] WCModuleConfig p2
         * @property {IRelayOutletConfig|null} [drain] WCModuleConfig drain
         * @property {IRelayOutletConfig|null} [pump0] WCModuleConfig pump0
         * @property {IRelayOutletConfig|null} [pump1] WCModuleConfig pump1
         * @property {IRelayOutletConfig|null} [pump2] WCModuleConfig pump2
         * @property {IRelayOutletConfig|null} [pump3] WCModuleConfig pump3
         */
    
        /**
         * Constructs a new WCModuleConfig.
         * @exports WCModuleConfig
         * @classdesc Represents a WCModuleConfig.
         * @implements IWCModuleConfig
         * @constructor
         * @param {IWCModuleConfig=} [properties] Properties to set
         */
        function WCModuleConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WCModuleConfig p0.
         * @member {IRelayOutletConfig|null|undefined} p0
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.p0 = null;
    
        /**
         * WCModuleConfig p1.
         * @member {IRelayOutletConfig|null|undefined} p1
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.p1 = null;
    
        /**
         * WCModuleConfig p2.
         * @member {IRelayOutletConfig|null|undefined} p2
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.p2 = null;
    
        /**
         * WCModuleConfig drain.
         * @member {IRelayOutletConfig|null|undefined} drain
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.drain = null;
    
        /**
         * WCModuleConfig pump0.
         * @member {IRelayOutletConfig|null|undefined} pump0
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.pump0 = null;
    
        /**
         * WCModuleConfig pump1.
         * @member {IRelayOutletConfig|null|undefined} pump1
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.pump1 = null;
    
        /**
         * WCModuleConfig pump2.
         * @member {IRelayOutletConfig|null|undefined} pump2
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.pump2 = null;
    
        /**
         * WCModuleConfig pump3.
         * @member {IRelayOutletConfig|null|undefined} pump3
         * @memberof WCModuleConfig
         * @instance
         */
        WCModuleConfig.prototype.pump3 = null;
    
        /**
         * Creates a new WCModuleConfig instance using the specified properties.
         * @function create
         * @memberof WCModuleConfig
         * @static
         * @param {IWCModuleConfig=} [properties] Properties to set
         * @returns {WCModuleConfig} WCModuleConfig instance
         */
        WCModuleConfig.create = function create(properties) {
            return new WCModuleConfig(properties);
        };
    
        /**
         * Encodes the specified WCModuleConfig message. Does not implicitly {@link WCModuleConfig.verify|verify} messages.
         * @function encode
         * @memberof WCModuleConfig
         * @static
         * @param {IWCModuleConfig} message WCModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WCModuleConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && Object.hasOwnProperty.call(message, "p0"))
                $root.RelayOutletConfig.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                $root.RelayOutletConfig.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                $root.RelayOutletConfig.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.drain != null && Object.hasOwnProperty.call(message, "drain"))
                $root.RelayOutletConfig.encode(message.drain, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pump0 != null && Object.hasOwnProperty.call(message, "pump0"))
                $root.RelayOutletConfig.encode(message.pump0, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pump1 != null && Object.hasOwnProperty.call(message, "pump1"))
                $root.RelayOutletConfig.encode(message.pump1, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pump2 != null && Object.hasOwnProperty.call(message, "pump2"))
                $root.RelayOutletConfig.encode(message.pump2, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.pump3 != null && Object.hasOwnProperty.call(message, "pump3"))
                $root.RelayOutletConfig.encode(message.pump3, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified WCModuleConfig message, length delimited. Does not implicitly {@link WCModuleConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WCModuleConfig
         * @static
         * @param {IWCModuleConfig} message WCModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WCModuleConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WCModuleConfig message from the specified reader or buffer.
         * @function decode
         * @memberof WCModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WCModuleConfig} WCModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WCModuleConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WCModuleConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p0 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.p1 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.p2 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.drain = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.pump0 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.pump1 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pump2 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.pump3 = $root.RelayOutletConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a WCModuleConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WCModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WCModuleConfig} WCModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WCModuleConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WCModuleConfig message.
         * @function verify
         * @memberof WCModuleConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WCModuleConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.RelayOutletConfig.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                var error = $root.RelayOutletConfig.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            if (message.p2 != null && message.hasOwnProperty("p2")) {
                var error = $root.RelayOutletConfig.verify(message.p2);
                if (error)
                    return "p2." + error;
            }
            if (message.drain != null && message.hasOwnProperty("drain")) {
                var error = $root.RelayOutletConfig.verify(message.drain);
                if (error)
                    return "drain." + error;
            }
            if (message.pump0 != null && message.hasOwnProperty("pump0")) {
                var error = $root.RelayOutletConfig.verify(message.pump0);
                if (error)
                    return "pump0." + error;
            }
            if (message.pump1 != null && message.hasOwnProperty("pump1")) {
                var error = $root.RelayOutletConfig.verify(message.pump1);
                if (error)
                    return "pump1." + error;
            }
            if (message.pump2 != null && message.hasOwnProperty("pump2")) {
                var error = $root.RelayOutletConfig.verify(message.pump2);
                if (error)
                    return "pump2." + error;
            }
            if (message.pump3 != null && message.hasOwnProperty("pump3")) {
                var error = $root.RelayOutletConfig.verify(message.pump3);
                if (error)
                    return "pump3." + error;
            }
            return null;
        };
    
        /**
         * Creates a WCModuleConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WCModuleConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WCModuleConfig} WCModuleConfig
         */
        WCModuleConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.WCModuleConfig)
                return object;
            var message = new $root.WCModuleConfig();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".WCModuleConfig.p0: object expected");
                message.p0 = $root.RelayOutletConfig.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".WCModuleConfig.p1: object expected");
                message.p1 = $root.RelayOutletConfig.fromObject(object.p1);
            }
            if (object.p2 != null) {
                if (typeof object.p2 !== "object")
                    throw TypeError(".WCModuleConfig.p2: object expected");
                message.p2 = $root.RelayOutletConfig.fromObject(object.p2);
            }
            if (object.drain != null) {
                if (typeof object.drain !== "object")
                    throw TypeError(".WCModuleConfig.drain: object expected");
                message.drain = $root.RelayOutletConfig.fromObject(object.drain);
            }
            if (object.pump0 != null) {
                if (typeof object.pump0 !== "object")
                    throw TypeError(".WCModuleConfig.pump0: object expected");
                message.pump0 = $root.RelayOutletConfig.fromObject(object.pump0);
            }
            if (object.pump1 != null) {
                if (typeof object.pump1 !== "object")
                    throw TypeError(".WCModuleConfig.pump1: object expected");
                message.pump1 = $root.RelayOutletConfig.fromObject(object.pump1);
            }
            if (object.pump2 != null) {
                if (typeof object.pump2 !== "object")
                    throw TypeError(".WCModuleConfig.pump2: object expected");
                message.pump2 = $root.RelayOutletConfig.fromObject(object.pump2);
            }
            if (object.pump3 != null) {
                if (typeof object.pump3 !== "object")
                    throw TypeError(".WCModuleConfig.pump3: object expected");
                message.pump3 = $root.RelayOutletConfig.fromObject(object.pump3);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a WCModuleConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WCModuleConfig
         * @static
         * @param {WCModuleConfig} message WCModuleConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WCModuleConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
                object.p2 = null;
                object.drain = null;
                object.pump0 = null;
                object.pump1 = null;
                object.pump2 = null;
                object.pump3 = null;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.RelayOutletConfig.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.RelayOutletConfig.toObject(message.p1, options);
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = $root.RelayOutletConfig.toObject(message.p2, options);
            if (message.drain != null && message.hasOwnProperty("drain"))
                object.drain = $root.RelayOutletConfig.toObject(message.drain, options);
            if (message.pump0 != null && message.hasOwnProperty("pump0"))
                object.pump0 = $root.RelayOutletConfig.toObject(message.pump0, options);
            if (message.pump1 != null && message.hasOwnProperty("pump1"))
                object.pump1 = $root.RelayOutletConfig.toObject(message.pump1, options);
            if (message.pump2 != null && message.hasOwnProperty("pump2"))
                object.pump2 = $root.RelayOutletConfig.toObject(message.pump2, options);
            if (message.pump3 != null && message.hasOwnProperty("pump3"))
                object.pump3 = $root.RelayOutletConfig.toObject(message.pump3, options);
            return object;
        };
    
        /**
         * Converts this WCModuleConfig to JSON.
         * @function toJSON
         * @memberof WCModuleConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WCModuleConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WCModuleConfig;
    })();

    return $root;
});
